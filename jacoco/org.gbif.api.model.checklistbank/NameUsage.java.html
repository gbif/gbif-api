<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NameUsage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common :: API</a> &gt; <a href="index.source.html" class="el_package">org.gbif.api.model.checklistbank</a> &gt; <span class="el_source">NameUsage.java</span></div><h1>NameUsage.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2020 Global Biodiversity Information Facility (GBIF)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.api.model.checklistbank;

import org.gbif.api.model.Constants;
import org.gbif.api.model.common.LinneanClassification;
import org.gbif.api.model.common.LinneanClassificationKeys;
import org.gbif.api.util.ClassificationUtils;
import org.gbif.api.vocabulary.NameType;
import org.gbif.api.vocabulary.NameUsageIssue;
import org.gbif.api.vocabulary.NomenclaturalStatus;
import org.gbif.api.vocabulary.Origin;
import org.gbif.api.vocabulary.Rank;
import org.gbif.api.vocabulary.TaxonomicStatus;

import java.net.URI;
import java.util.Date;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.Objects;
import java.util.Set;
import java.util.StringJoiner;
import java.util.UUID;

import javax.annotation.Nullable;
import javax.validation.constraints.NotNull;

import org.codehaus.jackson.annotate.JsonIgnore;
import org.codehaus.jackson.annotate.JsonProperty;

/**
 * A usage of a &lt;em&gt;scientific name&lt;/em&gt; according to one particular Checklist including the GBIF Taxonomic Backbone,
 * the nub. It is shown as species in the portal and API.
 *
 * All nub usages will have an empty nubKey. Backbone usages can be detected by either the NameUsage.isNub() method or by manually comparing the datasetKey
 * with the fixed backbone datasetKey, see Constants.NUB_DATASET_KEY.
 *
 * Name usages from other checklists with names that also exist in the nub will have a nubKey that points to the related usage in the nub.
 * To store not eagerly loaded subresources such as vernacular names or synonyms with a usage please use
 * the {@link NameUsageContainer} class.
 */
@SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L57">public class NameUsage implements LinneanClassification, LinneanClassificationKeys {</span>

  private Integer key;
  private Integer nubKey;
  private Integer nameKey;
  private String taxonID;
  private Integer sourceTaxonKey;
  // for LinneanClassification
  private String kingdom;
  private String phylum;
  @JsonProperty(&quot;class&quot;)
  private String clazz;
  private String order;
  private String family;
  private String genus;
  private String subgenus;
  private String species;
  // for LinneanClassificationKeys
  private Integer kingdomKey;
  private Integer phylumKey;
  private Integer classKey;
  private Integer orderKey;
  private Integer familyKey;
  private Integer genusKey;
  private Integer subgenusKey;
  private Integer speciesKey;

  private UUID datasetKey;
  private UUID constituentKey;
  private Integer parentKey;
  private String parent;
  private Integer proParteKey;
  private Integer acceptedKey;
  private String accepted;
  private Integer basionymKey;
  private String basionym;

  private String scientificName;
  private String canonicalName;
  private String vernacularName;
  private String authorship;
  private NameType nameType;
  private Rank rank;
  private Origin origin;
  private TaxonomicStatus taxonomicStatus;
<span class="fc" id="L102">  private Set&lt;NomenclaturalStatus&gt; nomenclaturalStatus = new HashSet&lt;&gt;();</span>
  private String remarks;
  private String publishedIn;
  private String accordingTo;

  private int numDescendants;
  private URI references;

  private Date modified;
  private Date deleted;
  private Date lastCrawled;
  private Date lastInterpreted;
<span class="fc" id="L114">  private Set&lt;NameUsageIssue&gt; issues = EnumSet.noneOf(NameUsageIssue.class);</span>

  /**
   * @return the name key for retrieving a parsed name object
   */
  public Integer getNameKey() {
<span class="fc" id="L120">    return nameKey;</span>
  }

  public void setNameKey(Integer nameKey) {
<span class="fc" id="L124">    this.nameKey = nameKey;</span>
<span class="fc" id="L125">  }</span>

  /**
   * For backbone taxa the source taxon key refers to the original name usage that was used during nub building
   * and is the primary reason that this taxon exists in the backbone.
   * &lt;br/&gt;
   * All nub usages are build from several underlying checklist usages,
   * but these are sorted by priority and the usage key for the highest priority one becomes the sourceTaxonKey
   * for a nub usage.
   * &lt;br/&gt;
   * Some nub usages do not have any source record altogether.
   * For example if there is a subspecies found, but no matching parent species,
   * the missing species will be created nevertheless and has no primary source.
   *
   * @return The key of the name usage this backbone taxon is derived from.
   */
  @Nullable
  public Integer getSourceTaxonKey() {
<span class="fc" id="L143">    return sourceTaxonKey;</span>
  }

  public void setSourceTaxonKey(Integer sourceTaxonKey) {
<span class="fc" id="L147">    this.sourceTaxonKey = sourceTaxonKey;</span>
<span class="fc" id="L148">  }</span>

  /**
   * @return the scientific name of the accepted name
   */
  public String getAccepted() {
<span class="fc" id="L154">    return accepted;</span>
  }

  /**
   * Sets the scientific name of the basionym, i.e. original name usage.
   */
  public void setAccepted(String accepted) {
<span class="fc" id="L161">    this.accepted = accepted;</span>
<span class="fc" id="L162">  }</span>

  /**
   * @return the name usage key of the accepted name
   */
  public Integer getAcceptedKey() {
<span class="fc" id="L168">    return acceptedKey;</span>
  }

  /**
   * Sets the usage key for the accepted name.
   */
  public void setAcceptedKey(Integer acceptedKey) {
<span class="fc" id="L175">    this.acceptedKey = acceptedKey;</span>
<span class="fc" id="L176">  }</span>

  /**
   * The taxon concept reference usually a reference to some publication or author + year.
   * The dwc:taxonAccordingTo reference is usually appended to the scientific name to further qualify the concept
   * with &quot;sensu&quot; or &quot;sec.&quot; being used for concatenation. E.g. &quot;Acer nigrum sec. Gleason Cronquist 1991&quot;.
   * In the case of backbone taxa this refers to the primary checklist the name was found in.
   *
   * @return the taxon concept reference
   */
  @Nullable
  public String getAccordingTo() {
<span class="fc" id="L188">    return accordingTo;</span>
  }

  /**
   * @param accordingTo the accordingTo to set
   */
  public void setAccordingTo(String accordingTo) {
<span class="fc" id="L195">    this.accordingTo = accordingTo;</span>
<span class="fc" id="L196">  }</span>

  /**
   * Returns the authorship information for the scientific name.
   *
   * @return the authorship
   */
  @Nullable
  public String getAuthorship() {
<span class="fc" id="L205">    return authorship;</span>
  }

  /**
   * @param authorship the authorship to set
   */
  public void setAuthorship(String authorship) {
<span class="fc" id="L212">    this.authorship = authorship;</span>
<span class="fc" id="L213">  }</span>

  /**
   * @return the scientific name of the basionym
   */
  public String getBasionym() {
<span class="fc" id="L219">    return basionym;</span>
  }

  /**
   * sets the basionym name.
   */
  public void setBasionym(String basionym) {
<span class="fc" id="L226">    this.basionym = basionym;</span>
<span class="fc" id="L227">  }</span>

  /**
   * Returns the earlier name (basionym) for this scientific name. Return null if the basionym does not exists.
   *
   * @return the basionymKey
   */
  @Nullable
  public Integer getBasionymKey() {
<span class="fc" id="L236">    return basionymKey;</span>
  }

  /**
   * @param basionymKey the basionymKey to set
   */
  public void setBasionymKey(Integer basionymKey) {
<span class="fc" id="L243">    this.basionymKey = basionymKey;</span>
<span class="fc" id="L244">  }</span>

  /**
   * @return the canonicalName
   */
  @Nullable
  public String getCanonicalName() {
<span class="fc" id="L251">    return canonicalName;</span>
  }

  /**
   * @param canonicalName the canonicalName to set
   */
  public void setCanonicalName(String canonicalName) {
<span class="fc" id="L258">    this.canonicalName = canonicalName;</span>
<span class="fc" id="L259">  }</span>

  /**
   * Returns the key of the checklist that &quot;hosts&quot; this name usage.
   *
   * @return the datasetKey
   */
  @NotNull
  public UUID getDatasetKey() {
<span class="fc" id="L268">    return datasetKey;</span>
  }

  /**
   * @param datasetKey the datasetKey to set
   */
  public void setDatasetKey(UUID datasetKey) {
<span class="fc" id="L275">    this.datasetKey = datasetKey;</span>
<span class="fc" id="L276">  }</span>

  /**
   * Return the key that uniquely identifies this name usage.
   *
   * @return the key
   */
  @NotNull
  public Integer getKey() {
<span class="fc" id="L285">    return key;</span>
  }

  /**
   * @param key the key to set
   */
  public void setKey(Integer key) {
<span class="fc" id="L292">    this.key = key;</span>
<span class="fc" id="L293">  }</span>

  /**
   * @return the type of name string classified by CLB.
   */
  public NameType getNameType() {
<span class="fc" id="L299">    return nameType;</span>
  }

  /**
   * @param nameType the type of name string
   */
  public void setNameType(NameType nameType) {
<span class="fc" id="L306">    this.nameType = nameType;</span>
<span class="fc" id="L307">  }</span>

  /**
   * The status related to the conformance to the relevant rules of nomenclature.
   * &lt;blockquote&gt;
   * &lt;p&gt;
   * &lt;i&gt;Example:&lt;/i&gt; &quot;invalid&quot;, &quot;misapplied&quot;, &quot;homotypic synonym&quot;, &quot;accepted&quot;
   * &lt;/p&gt;
   * &lt;/blockquote&gt;
   *
   * @return the set of known nomenclaturalStatus values
   *
   * @see &lt;a href=&quot;http://rs.gbif.org/vocabulary/gbif/nomenclatural_status.xml&quot;&gt;Nomenclatural Status GBIF
   *      Vocabulary&lt;/a&gt;
   */
  public Set&lt;NomenclaturalStatus&gt; getNomenclaturalStatus() {
<span class="fc" id="L323">    return nomenclaturalStatus;</span>
  }

  /**
   * @param nomenclaturalStatus the nomenclaturalStatus to set
   */
  public void setNomenclaturalStatus(Set&lt;NomenclaturalStatus&gt; nomenclaturalStatus) {
<span class="fc" id="L330">    this.nomenclaturalStatus = nomenclaturalStatus;</span>
<span class="fc" id="L331">  }</span>

  /**
   * @return the taxon key of the matching backbone name usage
   */
  @Nullable
  public Integer getNubKey() {
<span class="fc" id="L338">    return nubKey;</span>
  }

  /**
   * @param nubKey the nubKey to set
   */
  public void setNubKey(Integer nubKey) {
<span class="fc" id="L345">    this.nubKey = nubKey;</span>
<span class="fc" id="L346">  }</span>

  /**
   * The number of all accepted taxonomic elements under this usage.
   *
   * @return the number of descendants
   */
  public int getNumDescendants() {
<span class="fc" id="L354">    return numDescendants;</span>
  }

  /**
   * @param numDescendants the n umber of descendants to set
   */
  public void setNumDescendants(int numDescendants) {
<span class="fc" id="L361">    this.numDescendants = numDescendants;</span>
<span class="fc" id="L362">  }</span>

  /**
   * The origin of this name usage record, i.e. the reason why it exists.
   * In most cases this is because the record existed explicitly in the checklist sources, but
   * some usages are created de novo because they exist implicitly in the data.
   *
   * @return the name usage origin
   *
   * @see Origin
   */
  @NotNull
  public Origin getOrigin() {
<span class="fc" id="L375">    return origin;</span>
  }

  /**
   * @param origin the origin to set
   */
  public void setOrigin(Origin origin) {
<span class="fc" id="L382">    this.origin = origin;</span>
<span class="fc" id="L383">  }</span>

  /**
   * The scientific name of the parent.
   *
   * @return the parent name
   */
  public String getParent() {
<span class="fc" id="L391">    return parent;</span>
  }

  /**
   * @param parent the parent name to set
   */
  public void setParent(String parent) {
<span class="fc" id="L398">    this.parent = parent;</span>
<span class="fc" id="L399">  }</span>

  /**
   * Returns the immediate parent. If this usage if for the highest taxonomic level, return null.
   *
   * @return the parentKey
   */
  @Nullable
  public Integer getParentKey() {
<span class="fc" id="L408">    return parentKey;</span>
  }

  /**
   * @param parentKey the parentKey to set
   */
  public void setParentKey(Integer parentKey) {
<span class="fc" id="L415">    this.parentKey = parentKey;</span>
<span class="fc" id="L416">  }</span>

  /**
   * Pro parte synonyms, i.e. a synonym with multiple accepted names, are grouped by a single, primary name usage key.
   *
   * @return the primary name usage key for a prop parte synonym or null
   */
  public Integer getProParteKey() {
<span class="fc" id="L424">    return proParteKey;</span>
  }

  /**
   * Sets the pro parte usage key.
   */
  public void setProParteKey(Integer proParteKey) {
<span class="fc" id="L431">    this.proParteKey = proParteKey;</span>
<span class="fc" id="L432">  }</span>

  /**
   * Original publication for this name usage.
   *
   * @return the publishedIn
   */
  @Nullable
  public String getPublishedIn() {
<span class="fc" id="L441">    return publishedIn;</span>
  }

  /**
   * @param publishedIn the publishedIn to set
   */
  public void setPublishedIn(String publishedIn) {
<span class="fc" id="L448">    this.publishedIn = publishedIn;</span>
<span class="fc" id="L449">  }</span>

  /**
   * Returns the rank for this usage.
   * &lt;blockquote&gt;
   * &lt;p&gt;
   * &lt;i&gt;Example:&lt;/i&gt; &quot;Kingdom&quot;, &quot;Genus&quot;
   * &lt;/p&gt;
   * &lt;/blockquote&gt;
   *
   * @return the rank
   */
  @Nullable
  public Rank getRank() {
<span class="fc" id="L463">    return rank;</span>
  }

  /**
   * @param rank the rank to set
   */
  public void setRank(Rank rank) {
<span class="fc" id="L470">    this.rank = rank;</span>
<span class="fc" id="L471">  }</span>

  /**
   * The taxon name (with date and authorship information if applicable).
   * &lt;blockquote&gt;
   * &lt;p&gt;
   * &lt;i&gt;Example:&lt;/i&gt; &quot;Coleoptera&quot; (order), &quot;Vespertilionidae&quot; (family), &quot;Manis&quot; (genus), &quot;Ctenomys sociabilis&quot; (genus +
   * specificEpithet), &quot;Ambystoma tigrinum diaboli&quot; (genus + specificEpithet + infraspecificEpithet),
   * &quot;Quercus agrifolia var. oxyadenia (Torr.)&quot;
   * &lt;/p&gt;
   * &lt;/blockquote&gt;
   *
   * @return the scientificName
   */
  @NotNull
  public String getScientificName() {
<span class="fc" id="L487">    return scientificName;</span>
  }

  /**
   * @param scientificName the scientificName to set
   */
  public void setScientificName(String scientificName) {
<span class="fc" id="L494">    this.scientificName = scientificName;</span>
<span class="fc" id="L495">  }</span>

  /**
   * Return the optional sub dataset key for this usage.
   *
   * @return the subDatasetKey or null
   */
  @Nullable
  public UUID getConstituentKey() {
<span class="fc" id="L504">    return constituentKey;</span>
  }

  /**
   * @param constituentKey to set
   */
  public void setConstituentKey(UUID constituentKey) {
<span class="fc" id="L511">    this.constituentKey = constituentKey;</span>
<span class="fc" id="L512">  }</span>

  /**
   * A common or vernacular name for this usage.
   * &lt;blockquote&gt;
   * &lt;p&gt;
   * &lt;i&gt;Example:&lt;/i&gt; Andean Condor&quot;, &quot;Condor Andino&quot;, &quot;American Eagle&quot;, &quot;Gänsegeier&quot;.
   * &lt;/p&gt;
   * &lt;/blockquote&gt;
   *
   * @return the vernacularName
   */
  @Nullable
  public String getVernacularName() {
<span class="fc" id="L526">    return vernacularName;</span>
  }

  /**
   * @param vernacularName the vernacularName to set
   */
  public void setVernacularName(String vernacularName) {
<span class="fc" id="L533">    this.vernacularName = vernacularName;</span>
<span class="fc" id="L534">  }</span>

  /**
   * @param taxonomicStatus the taxonomicStatus to set
   */
  public void setTaxonomicStatus(TaxonomicStatus taxonomicStatus) {
<span class="fc" id="L540">    this.taxonomicStatus = taxonomicStatus;</span>
<span class="fc" id="L541">  }</span>

  @Override
  public String getKingdom() {
<span class="fc" id="L545">    return kingdom;</span>
  }

  @Override
  public void setKingdom(String kingdom) {
<span class="fc" id="L550">    this.kingdom = kingdom;</span>
<span class="fc" id="L551">  }</span>

  @Override
  public String getPhylum() {
<span class="fc" id="L555">    return phylum;</span>
  }

  @Override
  public void setPhylum(String phylum) {
<span class="fc" id="L560">    this.phylum = phylum;</span>
<span class="fc" id="L561">  }</span>

  @Override
  public String getClazz() {
<span class="fc" id="L565">    return clazz;</span>
  }

  @Override
  public void setClazz(String clazz) {
<span class="fc" id="L570">    this.clazz = clazz;</span>
<span class="fc" id="L571">  }</span>

  @Override
  public String getOrder() {
<span class="fc" id="L575">    return order;</span>
  }

  @Override
  public void setOrder(String order) {
<span class="fc" id="L580">    this.order = order;</span>
<span class="fc" id="L581">  }</span>

  @Override
  public String getFamily() {
<span class="fc" id="L585">    return family;</span>
  }

  @Override
  public void setFamily(String family) {
<span class="fc" id="L590">    this.family = family;</span>
<span class="fc" id="L591">  }</span>

  @Override
  public String getGenus() {
<span class="fc" id="L595">    return genus;</span>
  }

  @Override
  public void setGenus(String genus) {
<span class="fc" id="L600">    this.genus = genus;</span>
<span class="fc" id="L601">  }</span>

  @Override
  public String getSubgenus() {
<span class="fc" id="L605">    return subgenus;</span>
  }

  @Override
  public void setSubgenus(String subgenus) {
<span class="fc" id="L610">    this.subgenus = subgenus;</span>
<span class="fc" id="L611">  }</span>

  @Override
  public String getSpecies() {
<span class="fc" id="L615">    return species;</span>
  }

  @Override
  public void setSpecies(String species) {
<span class="fc" id="L620">    this.species = species;</span>
<span class="fc" id="L621">  }</span>

  @Override
  public Integer getKingdomKey() {
<span class="fc" id="L625">    return kingdomKey;</span>
  }

  @Override
  public void setKingdomKey(Integer kingdomKey) {
<span class="fc" id="L630">    this.kingdomKey = kingdomKey;</span>
<span class="fc" id="L631">  }</span>

  @Override
  public Integer getPhylumKey() {
<span class="fc" id="L635">    return phylumKey;</span>
  }

  @Override
  public void setPhylumKey(Integer phylumKey) {
<span class="fc" id="L640">    this.phylumKey = phylumKey;</span>
<span class="fc" id="L641">  }</span>

  @Override
  public Integer getClassKey() {
<span class="fc" id="L645">    return classKey;</span>
  }

  @Override
  public void setClassKey(Integer classKey) {
<span class="fc" id="L650">    this.classKey = classKey;</span>
<span class="fc" id="L651">  }</span>

  @Override
  public Integer getOrderKey() {
<span class="fc" id="L655">    return orderKey;</span>
  }

  @Override
  public void setOrderKey(Integer orderKey) {
<span class="fc" id="L660">    this.orderKey = orderKey;</span>
<span class="fc" id="L661">  }</span>

  @Override
  public Integer getFamilyKey() {
<span class="fc" id="L665">    return familyKey;</span>
  }

  @Override
  public void setFamilyKey(Integer familyKey) {
<span class="fc" id="L670">    this.familyKey = familyKey;</span>
<span class="fc" id="L671">  }</span>

  @Override
  public Integer getGenusKey() {
<span class="fc" id="L675">    return genusKey;</span>
  }

  @Override
  public void setGenusKey(Integer genusKey) {
<span class="fc" id="L680">    this.genusKey = genusKey;</span>
<span class="fc" id="L681">  }</span>

  @Override
  public Integer getSubgenusKey() {
<span class="fc" id="L685">    return subgenusKey;</span>
  }

  @Override
  public void setSubgenusKey(Integer subgenusKey) {
<span class="fc" id="L690">    this.subgenusKey = subgenusKey;</span>
<span class="fc" id="L691">  }</span>

  @Override
  public Integer getSpeciesKey() {
<span class="fc" id="L695">    return speciesKey;</span>
  }

  @Override
  public void setSpeciesKey(Integer speciesKey) {
<span class="fc" id="L700">    this.speciesKey = speciesKey;</span>
<span class="fc" id="L701">  }</span>

  public String getRemarks() {
<span class="fc" id="L704">    return remarks;</span>
  }

  public void setRemarks(String remarks) {
<span class="fc" id="L708">    this.remarks = remarks;</span>
<span class="fc" id="L709">  }</span>

  /**
   * @return the canonicalName or scientific name in case its null
   */
  @Nullable
  @JsonIgnore
  public String getCanonicalOrScientificName() {
<span class="nc bnc" id="L717" title="All 2 branches missed.">    return canonicalName == null ? scientificName : canonicalName;</span>
  }

  /**
   * A URI link or reference to the source of this record, the records &quot;homepage&quot;.
   * &lt;blockquote&gt;
   * &lt;p&gt;
   * &lt;i&gt;Example:&lt;/i&gt; http://www.catalogueoflife.org/annual-checklist/show_species_details.php?record_id=6197868
   * &lt;/p&gt;
   * &lt;/blockquote&gt;
   *
   * @return the link
   */
  @Nullable
  public URI getReferences() {
<span class="fc" id="L732">    return references;</span>
  }

  public void setReferences(URI references) {
<span class="fc" id="L736">    this.references = references;</span>
<span class="fc" id="L737">  }</span>

  @Override
  public String getHigherRank(Rank rank) {
<span class="nc" id="L741">    return ClassificationUtils.getHigherRank(this, rank);</span>
  }

  @Override
  public Integer getHigherRankKey(Rank rank) {
<span class="nc" id="L746">    return ClassificationUtils.getHigherRankKey(this, rank);</span>
  }

  /**
   * An ordered map with entries for all higher Linnean ranks down to the actual direct parent of this usage.
   * The map starts with the highest rank, e.g. the kingdom and maps the name usage key to its canonical name.
   * The name usage itself is never included, even though a higher rank might point to the usage itself.
   *
   * @return map of higher ranks
   */
  @NotNull
  @JsonIgnore
  public LinkedHashMap&lt;Integer, String&gt; getHigherClassificationMap() {
<span class="fc" id="L759">    return ClassificationUtils.getHigherClassificationMap(this, key, parentKey, parent);</span>
  }

  /**
   * The original taxonID of the name usage as found in the source.
   * For backbone taxa and name usages with an origin different to SOURCE this is null.
   */
  @Nullable
  public String getTaxonID() {
<span class="fc" id="L768">    return taxonID;</span>
  }

  /**
   * The taxonomic status of the name usage.
   * Can be null, but for all synonyms with an accepted name usage it is guaranteed to exist.
   *
   * @return the taxonomicStatus, can be null
   */
  @Nullable
  public TaxonomicStatus getTaxonomicStatus() {
<span class="fc" id="L779">    return taxonomicStatus;</span>
  }

  /**
   * The interpreted dc:modified from the verbatim source data.
   * Ideally indicating when a record was last modified in the source.
   */
  @Nullable
  public Date getModified() {
<span class="fc" id="L788">    return modified;</span>
  }

  public void setModified(Date modified) {
<span class="fc" id="L792">    this.modified = modified;</span>
<span class="fc" id="L793">  }</span>

  /**
   * The date this record was deleted.
   * Logical deletions only occur for backbone usages!
   */
  @Nullable
  public Date getDeleted() {
<span class="fc" id="L801">    return deleted;</span>
  }

  public void setDeleted(Date deleted) {
<span class="fc" id="L805">    this.deleted = deleted;</span>
<span class="fc" id="L806">  }</span>

  /**
   * The date this record was last crawled during clb indexing.
   */
  @Nullable
  public Date getLastCrawled() {
<span class="fc" id="L813">    return lastCrawled;</span>
  }

  public void setLastCrawled(Date lastCrawled) {
<span class="fc" id="L817">    this.lastCrawled = lastCrawled;</span>
<span class="fc" id="L818">  }</span>

  /**
   * The date this record was last interpreted during indexing.
   * This includes matching to the backbone.
   */
  @Nullable
  public Date getLastInterpreted() {
<span class="fc" id="L826">    return lastInterpreted;</span>
  }

  public void setLastInterpreted(Date lastInterpreted) {
<span class="fc" id="L830">    this.lastInterpreted = lastInterpreted;</span>
<span class="fc" id="L831">  }</span>

  @NotNull
  public Set&lt;NameUsageIssue&gt; getIssues() {
<span class="fc" id="L835">    return issues;</span>
  }

  public void setIssues(Set&lt;NameUsageIssue&gt; issues) {
<span class="fc" id="L839">    Objects.requireNonNull(issues, &quot;Issues cannot be null&quot;);</span>
<span class="fc bfc" id="L840" title="All 2 branches covered.">    this.issues = issues.isEmpty() ? EnumSet.noneOf(NameUsageIssue.class) : EnumSet.copyOf(issues);</span>
<span class="fc" id="L841">  }</span>

  public void addIssue(NameUsageIssue issue) {
<span class="nc" id="L844">    Objects.requireNonNull(issue, &quot;Issue needs to be specified&quot;);</span>
<span class="nc" id="L845">    this.issues.add(issue);</span>
<span class="nc" id="L846">  }</span>

  @JsonIgnore
  public boolean isNub() {
<span class="nc" id="L850">    return datasetKey.equals(Constants.NUB_DATASET_KEY);</span>
  }

  /**
   * True for pro parte synonyms with multiple accepted usages.
   *
   * @return true if proParte, false otherwise
   */
  @JsonIgnore
  public boolean isProParte() {
<span class="pc bpc" id="L860" title="1 of 2 branches missed.">    return proParteKey != null;</span>
  }

  /**
   * Convenience method using the taxonomicStatus field.
   * @return true if its a synonym
   */
  public boolean isSynonym() {
<span class="fc bfc" id="L868" title="All 4 branches covered.">    return taxonomicStatus != null &amp;&amp; taxonomicStatus.isSynonym();</span>
  }

  public void setTaxonID(String taxonID) {
<span class="fc" id="L872">    this.taxonID = taxonID;</span>
<span class="fc" id="L873">  }</span>

  @Override
  public boolean equals(Object o) {
<span class="fc bfc" id="L877" title="All 2 branches covered.">    if (this == o) {</span>
<span class="fc" id="L878">      return true;</span>
    }
<span class="pc bpc" id="L880" title="1 of 4 branches missed.">    if (o == null || getClass() != o.getClass()) {</span>
<span class="fc" id="L881">      return false;</span>
    }
<span class="fc" id="L883">    NameUsage nameUsage = (NameUsage) o;</span>
<span class="pc bpc" id="L884" title="1 of 2 branches missed.">    return numDescendants == nameUsage.numDescendants &amp;&amp;</span>
<span class="fc bfc" id="L885" title="All 2 branches covered.">      Objects.equals(key, nameUsage.key) &amp;&amp;</span>
<span class="pc bpc" id="L886" title="1 of 2 branches missed.">      Objects.equals(nubKey, nameUsage.nubKey) &amp;&amp;</span>
<span class="pc bpc" id="L887" title="1 of 2 branches missed.">      Objects.equals(nameKey, nameUsage.nameKey) &amp;&amp;</span>
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">      Objects.equals(taxonID, nameUsage.taxonID) &amp;&amp;</span>
<span class="pc bpc" id="L889" title="1 of 2 branches missed.">      Objects.equals(kingdom, nameUsage.kingdom) &amp;&amp;</span>
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">      Objects.equals(phylum, nameUsage.phylum) &amp;&amp;</span>
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">      Objects.equals(clazz, nameUsage.clazz) &amp;&amp;</span>
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">      Objects.equals(order, nameUsage.order) &amp;&amp;</span>
<span class="pc bpc" id="L893" title="1 of 2 branches missed.">      Objects.equals(family, nameUsage.family) &amp;&amp;</span>
<span class="pc bpc" id="L894" title="1 of 2 branches missed.">      Objects.equals(genus, nameUsage.genus) &amp;&amp;</span>
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">      Objects.equals(subgenus, nameUsage.subgenus) &amp;&amp;</span>
<span class="pc bpc" id="L896" title="1 of 2 branches missed.">      Objects.equals(species, nameUsage.species) &amp;&amp;</span>
<span class="pc bpc" id="L897" title="1 of 2 branches missed.">      Objects.equals(kingdomKey, nameUsage.kingdomKey) &amp;&amp;</span>
<span class="pc bpc" id="L898" title="1 of 2 branches missed.">      Objects.equals(phylumKey, nameUsage.phylumKey) &amp;&amp;</span>
<span class="pc bpc" id="L899" title="1 of 2 branches missed.">      Objects.equals(classKey, nameUsage.classKey) &amp;&amp;</span>
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">      Objects.equals(orderKey, nameUsage.orderKey) &amp;&amp;</span>
<span class="pc bpc" id="L901" title="1 of 2 branches missed.">      Objects.equals(familyKey, nameUsage.familyKey) &amp;&amp;</span>
<span class="pc bpc" id="L902" title="1 of 2 branches missed.">      Objects.equals(genusKey, nameUsage.genusKey) &amp;&amp;</span>
<span class="pc bpc" id="L903" title="1 of 2 branches missed.">      Objects.equals(subgenusKey, nameUsage.subgenusKey) &amp;&amp;</span>
<span class="pc bpc" id="L904" title="1 of 2 branches missed.">      Objects.equals(speciesKey, nameUsage.speciesKey) &amp;&amp;</span>
<span class="pc bpc" id="L905" title="1 of 2 branches missed.">      Objects.equals(datasetKey, nameUsage.datasetKey) &amp;&amp;</span>
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">      Objects.equals(constituentKey, nameUsage.constituentKey) &amp;&amp;</span>
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">      Objects.equals(parentKey, nameUsage.parentKey) &amp;&amp;</span>
<span class="pc bpc" id="L908" title="1 of 2 branches missed.">      Objects.equals(parent, nameUsage.parent) &amp;&amp;</span>
<span class="pc bpc" id="L909" title="1 of 2 branches missed.">      Objects.equals(proParteKey, nameUsage.proParteKey) &amp;&amp;</span>
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">      Objects.equals(acceptedKey, nameUsage.acceptedKey) &amp;&amp;</span>
<span class="pc bpc" id="L911" title="1 of 2 branches missed.">      Objects.equals(accepted, nameUsage.accepted) &amp;&amp;</span>
<span class="pc bpc" id="L912" title="1 of 2 branches missed.">      Objects.equals(basionymKey, nameUsage.basionymKey) &amp;&amp;</span>
<span class="pc bpc" id="L913" title="1 of 2 branches missed.">      Objects.equals(basionym, nameUsage.basionym) &amp;&amp;</span>
<span class="pc bpc" id="L914" title="1 of 2 branches missed.">      Objects.equals(scientificName, nameUsage.scientificName) &amp;&amp;</span>
<span class="pc bpc" id="L915" title="1 of 2 branches missed.">      Objects.equals(canonicalName, nameUsage.canonicalName) &amp;&amp;</span>
<span class="pc bpc" id="L916" title="1 of 2 branches missed.">      Objects.equals(vernacularName, nameUsage.vernacularName) &amp;&amp;</span>
<span class="pc bpc" id="L917" title="5 of 10 branches missed.">      Objects.equals(authorship, nameUsage.authorship) &amp;&amp;</span>
      nameType == nameUsage.nameType &amp;&amp;
      rank == nameUsage.rank &amp;&amp;
      origin == nameUsage.origin &amp;&amp;
      taxonomicStatus == nameUsage.taxonomicStatus &amp;&amp;
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">      Objects.equals(nomenclaturalStatus, nameUsage.nomenclaturalStatus) &amp;&amp;</span>
<span class="pc bpc" id="L923" title="1 of 2 branches missed.">      Objects.equals(remarks, nameUsage.remarks) &amp;&amp;</span>
<span class="pc bpc" id="L924" title="1 of 2 branches missed.">      Objects.equals(publishedIn, nameUsage.publishedIn) &amp;&amp;</span>
<span class="pc bpc" id="L925" title="1 of 2 branches missed.">      Objects.equals(accordingTo, nameUsage.accordingTo) &amp;&amp;</span>
<span class="pc bpc" id="L926" title="1 of 2 branches missed.">      Objects.equals(references, nameUsage.references) &amp;&amp;</span>
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">      Objects.equals(modified, nameUsage.modified) &amp;&amp;</span>
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">      Objects.equals(deleted, nameUsage.deleted) &amp;&amp;</span>
<span class="pc bpc" id="L929" title="1 of 2 branches missed.">      Objects.equals(lastCrawled, nameUsage.lastCrawled) &amp;&amp;</span>
<span class="pc bpc" id="L930" title="1 of 2 branches missed.">      Objects.equals(lastInterpreted, nameUsage.lastInterpreted) &amp;&amp;</span>
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">      Objects.equals(issues, nameUsage.issues);</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L936">    return Objects</span>
<span class="fc" id="L937">      .hash(key, nubKey, nameKey, taxonID, kingdom, phylum, clazz, order, family, genus, subgenus,</span>
        species, kingdomKey, phylumKey, classKey, orderKey, familyKey, genusKey, subgenusKey,
        speciesKey, datasetKey, constituentKey, parentKey, parent, proParteKey, acceptedKey,
        accepted, basionymKey, basionym, scientificName, canonicalName, vernacularName,
        authorship, nameType, rank, origin, taxonomicStatus, nomenclaturalStatus, remarks,
<span class="fc" id="L942">        publishedIn, accordingTo, numDescendants, references, modified, deleted, lastCrawled,</span>
        lastInterpreted, issues);
  }

  @Override
  public String toString() {
<span class="nc" id="L948">    return new StringJoiner(&quot;, &quot;, NameUsage.class.getSimpleName() + &quot;[&quot;, &quot;]&quot;)</span>
<span class="nc" id="L949">      .add(&quot;key=&quot; + key)</span>
<span class="nc" id="L950">      .add(&quot;nubKey=&quot; + nubKey)</span>
<span class="nc" id="L951">      .add(&quot;nameKey=&quot; + nameKey)</span>
<span class="nc" id="L952">      .add(&quot;taxonID='&quot; + taxonID + &quot;'&quot;)</span>
<span class="nc" id="L953">      .add(&quot;sourceTaxonKey=&quot; + sourceTaxonKey)</span>
<span class="nc" id="L954">      .add(&quot;kingdom='&quot; + kingdom + &quot;'&quot;)</span>
<span class="nc" id="L955">      .add(&quot;phylum='&quot; + phylum + &quot;'&quot;)</span>
<span class="nc" id="L956">      .add(&quot;clazz='&quot; + clazz + &quot;'&quot;)</span>
<span class="nc" id="L957">      .add(&quot;order='&quot; + order + &quot;'&quot;)</span>
<span class="nc" id="L958">      .add(&quot;family='&quot; + family + &quot;'&quot;)</span>
<span class="nc" id="L959">      .add(&quot;genus='&quot; + genus + &quot;'&quot;)</span>
<span class="nc" id="L960">      .add(&quot;subgenus='&quot; + subgenus + &quot;'&quot;)</span>
<span class="nc" id="L961">      .add(&quot;species='&quot; + species + &quot;'&quot;)</span>
<span class="nc" id="L962">      .add(&quot;kingdomKey=&quot; + kingdomKey)</span>
<span class="nc" id="L963">      .add(&quot;phylumKey=&quot; + phylumKey)</span>
<span class="nc" id="L964">      .add(&quot;classKey=&quot; + classKey)</span>
<span class="nc" id="L965">      .add(&quot;orderKey=&quot; + orderKey)</span>
<span class="nc" id="L966">      .add(&quot;familyKey=&quot; + familyKey)</span>
<span class="nc" id="L967">      .add(&quot;genusKey=&quot; + genusKey)</span>
<span class="nc" id="L968">      .add(&quot;subgenusKey=&quot; + subgenusKey)</span>
<span class="nc" id="L969">      .add(&quot;speciesKey=&quot; + speciesKey)</span>
<span class="nc" id="L970">      .add(&quot;datasetKey=&quot; + datasetKey)</span>
<span class="nc" id="L971">      .add(&quot;constituentKey=&quot; + constituentKey)</span>
<span class="nc" id="L972">      .add(&quot;parentKey=&quot; + parentKey)</span>
<span class="nc" id="L973">      .add(&quot;parent='&quot; + parent + &quot;'&quot;)</span>
<span class="nc" id="L974">      .add(&quot;proParteKey=&quot; + proParteKey)</span>
<span class="nc" id="L975">      .add(&quot;acceptedKey=&quot; + acceptedKey)</span>
<span class="nc" id="L976">      .add(&quot;accepted='&quot; + accepted + &quot;'&quot;)</span>
<span class="nc" id="L977">      .add(&quot;basionymKey=&quot; + basionymKey)</span>
<span class="nc" id="L978">      .add(&quot;basionym='&quot; + basionym + &quot;'&quot;)</span>
<span class="nc" id="L979">      .add(&quot;scientificName='&quot; + scientificName + &quot;'&quot;)</span>
<span class="nc" id="L980">      .add(&quot;canonicalName='&quot; + canonicalName + &quot;'&quot;)</span>
<span class="nc" id="L981">      .add(&quot;vernacularName='&quot; + vernacularName + &quot;'&quot;)</span>
<span class="nc" id="L982">      .add(&quot;authorship='&quot; + authorship + &quot;'&quot;)</span>
<span class="nc" id="L983">      .add(&quot;nameType=&quot; + nameType)</span>
<span class="nc" id="L984">      .add(&quot;rank=&quot; + rank)</span>
<span class="nc" id="L985">      .add(&quot;origin=&quot; + origin)</span>
<span class="nc" id="L986">      .add(&quot;taxonomicStatus=&quot; + taxonomicStatus)</span>
<span class="nc" id="L987">      .add(&quot;nomenclaturalStatus=&quot; + nomenclaturalStatus)</span>
<span class="nc" id="L988">      .add(&quot;remarks='&quot; + remarks + &quot;'&quot;)</span>
<span class="nc" id="L989">      .add(&quot;publishedIn='&quot; + publishedIn + &quot;'&quot;)</span>
<span class="nc" id="L990">      .add(&quot;accordingTo='&quot; + accordingTo + &quot;'&quot;)</span>
<span class="nc" id="L991">      .add(&quot;numDescendants=&quot; + numDescendants)</span>
<span class="nc" id="L992">      .add(&quot;references=&quot; + references)</span>
<span class="nc" id="L993">      .add(&quot;modified=&quot; + modified)</span>
<span class="nc" id="L994">      .add(&quot;deleted=&quot; + deleted)</span>
<span class="nc" id="L995">      .add(&quot;lastCrawled=&quot; + lastCrawled)</span>
<span class="nc" id="L996">      .add(&quot;lastInterpreted=&quot; + lastInterpreted)</span>
<span class="nc" id="L997">      .add(&quot;issues=&quot; + issues)</span>
<span class="nc" id="L998">      .toString();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>