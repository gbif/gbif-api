<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CitationGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common :: API</a> &gt; <a href="index.source.html" class="el_package">org.gbif.api.util</a> &gt; <span class="el_source">CitationGenerator.java</span></div><h1>CitationGenerator.java</h1><pre class="source lang-java linenums">/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.api.util;

import org.gbif.api.model.registry.Citation;
import org.gbif.api.model.registry.CitationContact;
import org.gbif.api.model.registry.Contact;
import org.gbif.api.model.registry.Dataset;
import org.gbif.api.model.registry.Organization;
import org.gbif.api.vocabulary.ContactType;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.StringJoiner;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;

import lombok.Builder;
import lombok.Data;
import org.gbif.api.vocabulary.EndpointType;

/**
 * Helper class tha generates a Citation String from {@link Dataset} and {@link Organization}
 * objects. Documentation : /docs/citations.md
 */
public final class CitationGenerator {

<span class="fc" id="L52">  private static final ZoneId UTC = ZoneId.of(&quot;UTC&quot;);</span>
<span class="fc" id="L53">  private static final ContactType MANDATORY_CONTACT_TYPE = ContactType.ORIGINATOR;</span>
<span class="fc" id="L54">  private static final EnumSet&lt;ContactType&gt; AUTHOR_CONTACT_TYPE =</span>
<span class="fc" id="L55">      EnumSet.of(ContactType.ORIGINATOR, ContactType.METADATA_AUTHOR);</span>
<span class="fc" id="L56">  private static final Predicate&lt;Contact&gt; IS_NAME_PROVIDED_FCT =</span>
<span class="fc" id="L57">      ctc -&gt; StringUtils.isNotBlank(ctc.getLastName());</span>
<span class="fc" id="L58">  private static final Predicate&lt;CitationContact&gt; IS_CONTACT_NAME_PROVIDED =</span>
<span class="fc" id="L59">      ctc -&gt; StringUtils.isNotBlank(ctc.getLastName());</span>
<span class="fc" id="L60">  private static final Predicate&lt;Contact&gt; IS_ELIGIBLE_CONTACT_TYPE =</span>
<span class="fc" id="L61">      ctc -&gt; AUTHOR_CONTACT_TYPE.contains(ctc.getType());</span>

  /** Utility class */
  private CitationGenerator() {}

  @SuppressWarnings(&quot;unused&quot;)
  public static CitationData generateCitation(Dataset dataset, Organization org) {
<span class="fc" id="L68">    Objects.requireNonNull(org, &quot;Organization shall be provided&quot;);</span>
<span class="fc" id="L69">    return generateCitation(dataset, org.getTitle());</span>
  }

  /**
   * Generate a citation for a {@link Dataset} using the publisher's provided citation.
   * @param dataset dataset
   * @return generated citation as {@link String}
   */
  @SuppressWarnings(&quot;unused&quot;)
  public static String generatePublisherProvidedCitation(Dataset dataset) {
<span class="nc" id="L79">    Objects.requireNonNull(dataset, &quot;Dataset shall be provided&quot;);</span>
<span class="nc" id="L80">    Objects.requireNonNull(dataset.getCitation(), &quot;Dataset.citation shall be provided&quot;);</span>
<span class="nc" id="L81">    String originalCitationText = dataset.getCitation().getText();</span>
<span class="nc" id="L82">    Objects.requireNonNull(originalCitationText, &quot;Dataset.citation.text shall be provided&quot;);</span>

<span class="nc" id="L84">    StringJoiner joiner = new StringJoiner(&quot; &quot;);</span>

<span class="nc" id="L86">    joiner.add(originalCitationText);</span>

    // Check DOI exists, and append it if it doesn't.
<span class="nc bnc" id="L89" title="All 2 branches missed.">    if (!originalCitationText.toLowerCase().contains(&quot;doi.org&quot;)</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">        &amp;&amp; !originalCitationText.toLowerCase().contains(&quot;doi:&quot;)) {</span>
      try {
<span class="nc" id="L92">        joiner.add(URLDecoder.decode(dataset.getDoi().getUrl().toString(), &quot;UTF-8&quot;));</span>
<span class="nc" id="L93">      } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L94">        throw new IllegalArgumentException(&quot;Couldn't decode DOI URL&quot;, e);</span>
<span class="nc" id="L95">      }</span>
    }

<span class="nc" id="L98">    joiner.add(&quot;accessed via GBIF.org on &quot; + LocalDate.now(UTC) + &quot;.&quot;);</span>

<span class="nc" id="L100">    return joiner.toString();</span>
  }

  /**
   * Generate a citation for a {@link Dataset} and its {@link Organization}. TODO add support for
   * i18n
   * @return generated citation as {@link String}
   */
  public static CitationData generateCitation(Dataset dataset, String organizationTitle) {

<span class="fc" id="L110">    Objects.requireNonNull(dataset, &quot;Dataset shall be provided&quot;);</span>
<span class="fc" id="L111">    Objects.requireNonNull(organizationTitle, &quot;Organization title shall be provided&quot;);</span>

<span class="fc" id="L113">    Citation citation = new Citation();</span>

<span class="fc" id="L115">    List&lt;CitationContact&gt; contacts = getAuthors(dataset.getContacts());</span>

<span class="fc" id="L117">    StringJoiner joiner = new StringJoiner(&quot; &quot;);</span>
<span class="fc" id="L118">    List&lt;String&gt; authorsName = generateAuthorsName(contacts);</span>
<span class="fc" id="L119">    String authors = String.join(&quot;, &quot;, authorsName);</span>

<span class="fc" id="L121">    boolean authorsNameAvailable = StringUtils.isNotBlank(authors);</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">    authors = authorsNameAvailable ? authors : organizationTitle;</span>

    // only add a dot if we are not going to add it with the year
<span class="fc bfc" id="L125" title="All 2 branches covered.">    authors += dataset.getPubDate() == null ? &quot;.&quot; : &quot;&quot;;</span>
<span class="fc" id="L126">    joiner.add(authors);</span>

<span class="fc bfc" id="L128" title="All 2 branches covered.">    if (dataset.getPubDate() != null) {</span>
<span class="fc" id="L129">      joiner.add(&quot;(&quot; + dataset.getPubDate().toInstant().atZone(UTC).getYear() + &quot;).&quot;);</span>
    }

    // add title
<span class="fc" id="L133">    joiner.add(StringUtils.trim(dataset.getTitle()) + &quot;.&quot;);</span>

    // add version
<span class="fc bfc" id="L136" title="All 2 branches covered.">    if (dataset.getVersion() != null) {</span>
<span class="fc" id="L137">      joiner.add(&quot;Version &quot; + dataset.getVersion() + &quot;.&quot;);</span>
    }

    // add publisher except if it was used instead of the authors
<span class="fc bfc" id="L141" title="All 2 branches covered.">    if (authorsNameAvailable) {</span>
<span class="fc" id="L142">      joiner.add(StringUtils.trim(organizationTitle) + &quot;.&quot;);</span>
    }

<span class="pc bpc" id="L145" title="1 of 2 branches missed.">    if (dataset.getType() != null) {</span>
<span class="fc" id="L146">      joiner.add(StringUtils.capitalize(dataset.getType().name().replace('_', ' ').toLowerCase()));</span>
    }
<span class="fc" id="L148">    joiner.add(&quot;dataset&quot;);</span>

    // add DOI as the identifier.
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">    if (dataset.getDoi() != null) {</span>
      try {
<span class="fc" id="L153">        joiner.add(</span>
<span class="fc" id="L154">            URLDecoder.decode(dataset.getDoi().getUrl().toString(), StandardCharsets.UTF_8.name()));</span>
<span class="nc" id="L155">      } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L156">        throw new IllegalArgumentException(&quot;Couldn't decode DOI URL&quot;, e);</span>
<span class="fc" id="L157">      }</span>
    }

<span class="fc" id="L160">    joiner.add(&quot;accessed via GBIF.org on &quot; + LocalDate.now(UTC) + &quot;.&quot;);</span>

<span class="fc" id="L162">    citation.setText(joiner.toString());</span>
<span class="fc" id="L163">    citation.setCitationProvidedBySource(false);</span>

<span class="fc" id="L165">    return CitationData.builder().citation(citation).contacts(contacts).build();</span>
  }

  /**
   * Extracts an ordered list of unique authors from a list of contacts. A {@link Contact} is
   * identified as an author when his {@link ContactType} is contained in {@link
   * #AUTHOR_CONTACT_TYPE}. But, we shall at least have one contact of type MANDATORY_CONTACT_TYPE.
   *
   * @param contacts list of contacts available
   * @return ordered list of authors or empty list, never null
   */
  public static List&lt;CitationContact&gt; getAuthors(List&lt;Contact&gt; contacts) {
<span class="pc bpc" id="L177" title="2 of 4 branches missed.">    if (contacts == null || contacts.isEmpty()) {</span>
<span class="nc" id="L178">      return Collections.emptyList();</span>
    }

<span class="fc" id="L181">    List&lt;CitationContact&gt; uniqueContacts =</span>
<span class="fc" id="L182">        getUniqueAuthors(</span>
<span class="fc" id="L183">            contacts, ctc -&gt; IS_NAME_PROVIDED_FCT.and(IS_ELIGIBLE_CONTACT_TYPE).test(ctc));</span>

    // make sure we have at least one instance of {@link #MANDATORY_CONTACT_TYPE}
<span class="fc" id="L186">    Optional&lt;CitationContact&gt; firstOriginator =</span>
<span class="fc" id="L187">        uniqueContacts.stream()</span>
<span class="fc" id="L188">            .filter(ctc -&gt; ctc.getRoles().contains(MANDATORY_CONTACT_TYPE))</span>
<span class="fc" id="L189">            .findFirst();</span>

<span class="fc bfc" id="L191" title="All 2 branches covered.">    if (firstOriginator.isPresent()) {</span>
<span class="fc" id="L192">      return uniqueContacts;</span>
    }
<span class="fc" id="L194">    return Collections.emptyList();</span>
  }

  /**
   * Given a list of authors, generates a {@link List} of {@link String} representing the authors
   * name. If a contact doesn't have a first AND last name it will not be included.
   *
   * @param authors ordered list of authors
   * @return list of author names (if it can be generated) or empty list, never null
   */
  public static List&lt;String&gt; generateAuthorsName(List&lt;CitationContact&gt; authors) {
<span class="pc bpc" id="L205" title="1 of 4 branches missed.">    if (authors == null || authors.isEmpty()) {</span>
<span class="fc" id="L206">      return Collections.emptyList();</span>
    }

<span class="fc" id="L209">    return authors.stream()</span>
<span class="fc" id="L210">        .filter(IS_CONTACT_NAME_PROVIDED)</span>
<span class="fc" id="L211">        .map(CitationContact::getAbbreviatedName)</span>
<span class="fc" id="L212">        .collect(Collectors.toList());</span>
  }

  /**
   * This method is used to get the list of &quot;unique&quot; authors. Currently, uniqueness is based on
   * lastName + firstNames. The order of the provided list will be preserved which also means the
   * first {@link ContactType} found for a contact is the one that will be used for this contact
   * (after applying the filter).
   *
   * @param authors a list of contacts representing possible authors
   * @param filter {@link Predicate} used to pre-filter contacts
   * @return list of contacts
   */
  private static List&lt;CitationContact&gt; getUniqueAuthors(
      List&lt;Contact&gt; authors, Predicate&lt;Contact&gt; filter) {
<span class="fc" id="L227">    List&lt;CitationContact&gt; uniqueContact = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">    if (authors != null) {</span>
<span class="fc" id="L229">      authors.forEach(</span>
          ctc -&gt; {
<span class="fc bfc" id="L231" title="All 2 branches covered.">            if (filter.test(ctc)) {</span>
<span class="fc" id="L232">              Optional&lt;CitationContact&gt; author = findInAuthorList(ctc, uniqueContact);</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">              if (!author.isPresent()) {</span>
<span class="fc" id="L234">                HashSet&lt;ContactType&gt; contactTypes = new HashSet&lt;&gt;();</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">                if (ctc.getType() != null) {</span>
<span class="fc" id="L236">                  contactTypes.add(ctc.getType());</span>
                }
<span class="fc" id="L238">                HashSet&lt;String&gt; userIds = new HashSet&lt;&gt;();</span>
<span class="pc bpc" id="L239" title="1 of 4 branches missed.">                if (ctc.getUserId() != null &amp;&amp; !ctc.getUserId().isEmpty()) {</span>
<span class="fc" id="L240">                  userIds.addAll(ctc.getUserId());</span>
                }
<span class="fc" id="L242">                uniqueContact.add(</span>
                    new CitationContact(
<span class="fc" id="L244">                        ctc.getKey(),</span>
<span class="fc" id="L245">                        getAuthorName(ctc),</span>
<span class="fc" id="L246">                        ctc.getFirstName(),</span>
<span class="fc" id="L247">                        ctc.getLastName(),</span>
                        contactTypes,
                        userIds));
<span class="fc" id="L250">              } else {</span>
<span class="fc" id="L251">                author.ifPresent(</span>
                    a -&gt; {
<span class="fc" id="L253">                      a.getRoles().add(ctc.getType());</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">                      if (ctc.getUserId() != null) {</span>
<span class="fc" id="L255">                        a.getUserId().addAll(ctc.getUserId());</span>
                      }
<span class="fc" id="L257">                    });</span>
              }
            }
<span class="fc" id="L260">          });</span>
    }
<span class="fc" id="L262">    return uniqueContact;</span>
  }

  /**
   * Check if a specific {@link Contact} is NOT already in the list of &quot;unique&quot; contact. Currently,
   * uniqueness is based on the comparisons of lastName and firstNames.
   *
   * @param ctc contact to check
   * @param uniqueContacts list of contacts
   * @return contact wrapped in optional
   */
  private static Optional&lt;CitationContact&gt; findInAuthorList(
      Contact ctc, List&lt;CitationContact&gt; uniqueContacts) {
<span class="fc" id="L275">    return uniqueContacts.stream()</span>
<span class="fc" id="L276">        .filter(</span>
            author -&gt;
<span class="fc bfc" id="L278" title="All 2 branches covered.">                StringUtils.equalsIgnoreCase(ctc.getLastName(), author.getLastName())</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">                    &amp;&amp; StringUtils.equalsIgnoreCase(ctc.getFirstName(), author.getFirstName()))</span>
<span class="fc" id="L280">        .findFirst();</span>
  }

  /**
   * Given a {@link Contact}, generates a String for that contact for citation purpose. The
   * organization will be used (if present) in case we don't have both lastName and firstNames of
   * the contact.
   *
   * @param creator contact object
   * @return name
   */
  public static String getAuthorName(Contact creator) {
<span class="fc" id="L292">    StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L293">    String lastName = StringUtils.trimToNull(creator.getLastName());</span>
<span class="fc" id="L294">    String firstNames = StringUtils.trimToNull(creator.getFirstName());</span>
<span class="fc" id="L295">    String organization = StringUtils.trimToNull(creator.getOrganization());</span>

<span class="fc bfc" id="L297" title="All 4 branches covered.">    if (lastName != null &amp;&amp; firstNames != null) {</span>
<span class="fc" id="L298">      sb.append(lastName);</span>
<span class="fc" id="L299">      sb.append(&quot; &quot;);</span>
      // add first initial of each first name, capitalized
<span class="fc" id="L301">      String[] names = firstNames.split(&quot;\\s+&quot;);</span>

<span class="fc" id="L303">      sb.append(</span>
<span class="fc" id="L304">          Arrays.stream(names)</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">              .filter(str -&gt; !StringUtils.isBlank(str))</span>
<span class="fc" id="L306">              .map(str -&gt; StringUtils.upperCase(String.valueOf(str.charAt(0))))</span>
<span class="fc" id="L307">              .collect(Collectors.joining(&quot; &quot;)));</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">    } else if (lastName != null) {</span>
<span class="fc" id="L309">      sb.append(lastName);</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">    } else if (organization != null) {</span>
<span class="fc" id="L311">      sb.append(organization);</span>
    }
<span class="fc" id="L313">    return sb.toString();</span>
  }

<span class="nc bnc" id="L316" title="All 22 branches missed.">  @Data</span>
<span class="pc" id="L317">  @Builder</span>
  public static class CitationData {

<span class="fc" id="L320">    private final Citation citation;</span>
<span class="fc" id="L321">    private final List&lt;CitationContact&gt; contacts;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>