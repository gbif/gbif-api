<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CitationGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common :: API</a> &gt; <a href="index.source.html" class="el_package">org.gbif.api.util</a> &gt; <span class="el_source">CitationGenerator.java</span></div><h1>CitationGenerator.java</h1><pre class="source lang-java linenums">/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.api.util;

import org.gbif.api.model.registry.Citation;
import org.gbif.api.model.registry.CitationContact;
import org.gbif.api.model.registry.Contact;
import org.gbif.api.model.registry.Dataset;
import org.gbif.api.model.registry.Endpoint;
import org.gbif.api.model.registry.Organization;
import org.gbif.api.vocabulary.ContactType;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.StringJoiner;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;

import lombok.Builder;
import lombok.Data;
import org.gbif.api.vocabulary.EndpointType;

/**
 * Helper class tha generates a Citation String from {@link Dataset} and {@link Organization}
 * objects. Documentation : /docs/citations.md
 */
public final class CitationGenerator {

<span class="fc" id="L53">  private static final ZoneId UTC = ZoneId.of(&quot;UTC&quot;);</span>
<span class="fc" id="L54">  private static final ContactType MANDATORY_CONTACT_TYPE = ContactType.ORIGINATOR;</span>
<span class="fc" id="L55">  private static final EnumSet&lt;ContactType&gt; AUTHOR_CONTACT_TYPE =</span>
<span class="fc" id="L56">      EnumSet.of(ContactType.ORIGINATOR, ContactType.METADATA_AUTHOR);</span>
<span class="fc" id="L57">  private static final EnumSet&lt;ContactType&gt; CAMTRAP_CITATION_CONTACT_TYPE =</span>
<span class="fc" id="L58">      EnumSet.of(ContactType.POINT_OF_CONTACT, ContactType.PRINCIPAL_INVESTIGATOR, ContactType.CONTENT_PROVIDER);</span>
<span class="fc" id="L59">  private static final Predicate&lt;Contact&gt; IS_NAME_PROVIDED_FCT =</span>
<span class="fc" id="L60">      ctc -&gt; StringUtils.isNotBlank(ctc.getLastName());</span>
<span class="fc" id="L61">  private static final Predicate&lt;CitationContact&gt; IS_CONTACT_NAME_PROVIDED =</span>
<span class="fc" id="L62">      ctc -&gt; StringUtils.isNotBlank(ctc.getLastName());</span>
<span class="fc" id="L63">  private static final Predicate&lt;Contact&gt; IS_ELIGIBLE_CONTACT_TYPE =</span>
<span class="fc" id="L64">      ctc -&gt; AUTHOR_CONTACT_TYPE.contains(ctc.getType());</span>
<span class="fc" id="L65">  private static final Predicate&lt;Contact&gt; IS_ELIGIBLE_CAMTRAP_CONTACT_TYPE =</span>
<span class="fc" id="L66">      ctc -&gt; CAMTRAP_CITATION_CONTACT_TYPE.contains(ctc.getType());</span>

  /** Utility class */
  private CitationGenerator() {}

  @SuppressWarnings(&quot;unused&quot;)
  public static CitationData generateCitation(Dataset dataset, Organization org) {
<span class="fc" id="L73">    Objects.requireNonNull(org, &quot;Organization shall be provided&quot;);</span>
<span class="fc" id="L74">    return generateCitation(dataset, org.getTitle());</span>
  }

  /**
   * Generate a citation for a {@link Dataset} using the publisher's provided citation.
   * @param dataset dataset
   * @return generated citation as {@link String}
   */
  @SuppressWarnings(&quot;unused&quot;)
  public static String generatePublisherProvidedCitation(Dataset dataset) {
<span class="nc" id="L84">    Objects.requireNonNull(dataset, &quot;Dataset shall be provided&quot;);</span>
<span class="nc" id="L85">    Objects.requireNonNull(dataset.getCitation(), &quot;Dataset.citation shall be provided&quot;);</span>
<span class="nc" id="L86">    String originalCitationText = dataset.getCitation().getText();</span>
<span class="nc" id="L87">    Objects.requireNonNull(originalCitationText, &quot;Dataset.citation.text shall be provided&quot;);</span>

<span class="nc" id="L89">    StringJoiner joiner = new StringJoiner(&quot; &quot;);</span>

<span class="nc" id="L91">    joiner.add(originalCitationText);</span>

    // Check DOI exists, and append it if it doesn't.
<span class="nc bnc" id="L94" title="All 2 branches missed.">    if (!originalCitationText.toLowerCase().contains(&quot;doi.org&quot;)</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">        &amp;&amp; !originalCitationText.toLowerCase().contains(&quot;doi:&quot;)) {</span>
      try {
<span class="nc" id="L97">        joiner.add(URLDecoder.decode(dataset.getDoi().getUrl().toString(), &quot;UTF-8&quot;));</span>
<span class="nc" id="L98">      } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L99">        throw new IllegalArgumentException(&quot;Couldn't decode DOI URL&quot;, e);</span>
<span class="nc" id="L100">      }</span>
    }

<span class="nc" id="L103">    joiner.add(&quot;accessed via GBIF.org on &quot; + LocalDate.now(UTC) + &quot;.&quot;);</span>

<span class="nc" id="L105">    return joiner.toString();</span>
  }

  /**
   * Generate a citation for a {@link Dataset} and its {@link Organization}. TODO add support for
   * i18n
   * @return generated citation as {@link String}
   */
  public static CitationData generateCitation(Dataset dataset, String organizationTitle) {

<span class="fc" id="L115">    Objects.requireNonNull(dataset, &quot;Dataset shall be provided&quot;);</span>
<span class="fc" id="L116">    Objects.requireNonNull(organizationTitle, &quot;Organization title shall be provided&quot;);</span>

<span class="fc" id="L118">    Citation citation = new Citation();</span>

<span class="fc" id="L120">    List&lt;CitationContact&gt; contacts = getAuthors(dataset);</span>

<span class="fc" id="L122">    StringJoiner joiner = new StringJoiner(&quot; &quot;);</span>
<span class="fc" id="L123">    List&lt;String&gt; authorsName = generateAuthorsName(contacts);</span>
<span class="fc" id="L124">    String authors = String.join(&quot;, &quot;, authorsName);</span>

<span class="fc" id="L126">    boolean authorsNameAvailable = StringUtils.isNotBlank(authors);</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">    authors = authorsNameAvailable ? authors : organizationTitle;</span>

    // only add a dot if we are not going to add it with the year
<span class="fc bfc" id="L130" title="All 2 branches covered.">    authors += dataset.getPubDate() == null ? &quot;.&quot; : &quot;&quot;;</span>
<span class="fc" id="L131">    joiner.add(authors);</span>

<span class="fc bfc" id="L133" title="All 2 branches covered.">    if (dataset.getPubDate() != null) {</span>
<span class="fc" id="L134">      joiner.add(&quot;(&quot; + dataset.getPubDate().toInstant().atZone(UTC).getYear() + &quot;).&quot;);</span>
    }

    // add title
<span class="fc" id="L138">    joiner.add(StringUtils.trim(dataset.getTitle()) + &quot;.&quot;);</span>

    // add version
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">    if (dataset.getVersion() != null) {</span>
<span class="fc" id="L142">      joiner.add(&quot;Version &quot; + dataset.getVersion() + &quot;.&quot;);</span>
    }

    // add publisher except if it was used instead of the authors
<span class="fc bfc" id="L146" title="All 2 branches covered.">    if (authorsNameAvailable) {</span>
<span class="fc" id="L147">      joiner.add(StringUtils.trim(organizationTitle) + &quot;.&quot;);</span>
    }

<span class="pc bpc" id="L150" title="1 of 2 branches missed.">    if (dataset.getType() != null) {</span>
<span class="fc" id="L151">      joiner.add(StringUtils.capitalize(dataset.getType().name().replace('_', ' ').toLowerCase()));</span>
    }
<span class="fc" id="L153">    joiner.add(&quot;dataset&quot;);</span>

    // add DOI as the identifier.
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">    if (dataset.getDoi() != null) {</span>
      try {
<span class="fc" id="L158">        joiner.add(</span>
<span class="fc" id="L159">            URLDecoder.decode(dataset.getDoi().getUrl().toString(), StandardCharsets.UTF_8.name()));</span>
<span class="nc" id="L160">      } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L161">        throw new IllegalArgumentException(&quot;Couldn't decode DOI URL&quot;, e);</span>
<span class="fc" id="L162">      }</span>
    }

<span class="fc" id="L165">    joiner.add(&quot;accessed via GBIF.org on &quot; + LocalDate.now(UTC) + &quot;.&quot;);</span>

<span class="fc" id="L167">    citation.setText(joiner.toString());</span>
<span class="fc" id="L168">    citation.setCitationProvidedBySource(false);</span>

<span class="fc" id="L170">    return CitationData.builder().citation(citation).contacts(contacts).build();</span>
  }

  public static List&lt;CitationContact&gt; getAuthors(Dataset dataset) {
<span class="fc" id="L174">    boolean isCamtrap = dataset.getEndpoints().stream()</span>
<span class="fc" id="L175">        .map(Endpoint::getType)</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        .anyMatch(e -&gt; e == EndpointType.CAMTRAP_DP);</span>

<span class="fc bfc" id="L178" title="All 2 branches covered.">    return isCamtrap ? getAuthorsForCamtrap(dataset.getContacts()) : getAuthors(dataset.getContacts());</span>
  }

  public static List&lt;CitationContact&gt; getAuthorsForCamtrap(List&lt;Contact&gt; contacts) {
<span class="pc bpc" id="L182" title="2 of 4 branches missed.">    if (contacts == null || contacts.isEmpty()) {</span>
<span class="nc" id="L183">      return Collections.emptyList();</span>
    }

<span class="fc" id="L186">    return getUniqueAuthors(</span>
<span class="fc" id="L187">        contacts, ctc -&gt; IS_NAME_PROVIDED_FCT.and(IS_ELIGIBLE_CAMTRAP_CONTACT_TYPE).test(ctc));</span>
  }

  /**
   * Extracts an ordered list of unique authors from a list of contacts. A {@link Contact} is
   * identified as an author when his {@link ContactType} is contained in {@link
   * #AUTHOR_CONTACT_TYPE}. But, we shall at least have one contact of type MANDATORY_CONTACT_TYPE.
   *
   * @param contacts list of contacts available
   * @return ordered list of authors or empty list, never null
   */
  public static List&lt;CitationContact&gt; getAuthors(List&lt;Contact&gt; contacts) {
<span class="pc bpc" id="L199" title="2 of 4 branches missed.">    if (contacts == null || contacts.isEmpty()) {</span>
<span class="nc" id="L200">      return Collections.emptyList();</span>
    }

<span class="fc" id="L203">    List&lt;CitationContact&gt; uniqueContacts =</span>
<span class="fc" id="L204">        getUniqueAuthors(</span>
<span class="fc" id="L205">            contacts, ctc -&gt; IS_NAME_PROVIDED_FCT.and(IS_ELIGIBLE_CONTACT_TYPE).test(ctc));</span>

    // make sure we have at least one instance of {@link #MANDATORY_CONTACT_TYPE}
<span class="fc" id="L208">    Optional&lt;CitationContact&gt; firstOriginator =</span>
<span class="fc" id="L209">        uniqueContacts.stream()</span>
<span class="fc" id="L210">            .filter(ctc -&gt; ctc.getRoles().contains(MANDATORY_CONTACT_TYPE))</span>
<span class="fc" id="L211">            .findFirst();</span>

<span class="fc bfc" id="L213" title="All 2 branches covered.">    if (firstOriginator.isPresent()) {</span>
<span class="fc" id="L214">      return uniqueContacts;</span>
    }
<span class="fc" id="L216">    return Collections.emptyList();</span>
  }

  /**
   * Given a list of authors, generates a {@link List} of {@link String} representing the authors
   * name. If a contact doesn't have a first AND last name it will not be included.
   *
   * @param authors ordered list of authors
   * @return list of author names (if it can be generated) or empty list, never null
   */
  public static List&lt;String&gt; generateAuthorsName(List&lt;CitationContact&gt; authors) {
<span class="pc bpc" id="L227" title="1 of 4 branches missed.">    if (authors == null || authors.isEmpty()) {</span>
<span class="fc" id="L228">      return Collections.emptyList();</span>
    }

<span class="fc" id="L231">    return authors.stream()</span>
<span class="fc" id="L232">        .filter(IS_CONTACT_NAME_PROVIDED)</span>
<span class="fc" id="L233">        .map(CitationContact::getAbbreviatedName)</span>
<span class="fc" id="L234">        .collect(Collectors.toList());</span>
  }

  /**
   * This method is used to get the list of &quot;unique&quot; authors. Currently, uniqueness is based on
   * lastName + firstNames. The order of the provided list will be preserved which also means the
   * first {@link ContactType} found for a contact is the one that will be used for this contact
   * (after applying the filter).
   *
   * @param authors a list of contacts representing possible authors
   * @param filter {@link Predicate} used to pre-filter contacts
   * @return list of contacts
   */
  private static List&lt;CitationContact&gt; getUniqueAuthors(
      List&lt;Contact&gt; authors, Predicate&lt;Contact&gt; filter) {
<span class="fc" id="L249">    List&lt;CitationContact&gt; uniqueContact = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">    if (authors != null) {</span>
<span class="fc" id="L251">      authors.forEach(</span>
          ctc -&gt; {
<span class="fc bfc" id="L253" title="All 2 branches covered.">            if (filter.test(ctc)) {</span>
<span class="fc" id="L254">              Optional&lt;CitationContact&gt; author = findInAuthorList(ctc, uniqueContact);</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">              if (!author.isPresent()) {</span>
<span class="fc" id="L256">                HashSet&lt;ContactType&gt; contactTypes = new HashSet&lt;&gt;();</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">                if (ctc.getType() != null) {</span>
<span class="fc" id="L258">                  contactTypes.add(ctc.getType());</span>
                }
<span class="fc" id="L260">                HashSet&lt;String&gt; userIds = new HashSet&lt;&gt;();</span>
<span class="pc bpc" id="L261" title="1 of 4 branches missed.">                if (ctc.getUserId() != null &amp;&amp; !ctc.getUserId().isEmpty()) {</span>
<span class="fc" id="L262">                  userIds.addAll(ctc.getUserId());</span>
                }
<span class="fc" id="L264">                uniqueContact.add(</span>
                    new CitationContact(
<span class="fc" id="L266">                        ctc.getKey(),</span>
<span class="fc" id="L267">                        getAuthorName(ctc),</span>
<span class="fc" id="L268">                        ctc.getFirstName(),</span>
<span class="fc" id="L269">                        ctc.getLastName(),</span>
                        contactTypes,
                        userIds));
<span class="fc" id="L272">              } else {</span>
<span class="fc" id="L273">                author.ifPresent(</span>
                    a -&gt; {
<span class="fc" id="L275">                      a.getRoles().add(ctc.getType());</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">                      if (ctc.getUserId() != null) {</span>
<span class="fc" id="L277">                        a.getUserId().addAll(ctc.getUserId());</span>
                      }
<span class="fc" id="L279">                    });</span>
              }
            }
<span class="fc" id="L282">          });</span>
    }
<span class="fc" id="L284">    return uniqueContact;</span>
  }

  /**
   * Check if a specific {@link Contact} is NOT already in the list of &quot;unique&quot; contact. Currently,
   * uniqueness is based on the comparisons of lastName and firstNames.
   *
   * @param ctc contact to check
   * @param uniqueContacts list of contacts
   * @return contact wrapped in optional
   */
  private static Optional&lt;CitationContact&gt; findInAuthorList(
      Contact ctc, List&lt;CitationContact&gt; uniqueContacts) {
<span class="fc" id="L297">    return uniqueContacts.stream()</span>
<span class="fc" id="L298">        .filter(</span>
            author -&gt;
<span class="fc bfc" id="L300" title="All 2 branches covered.">                StringUtils.equalsIgnoreCase(ctc.getLastName(), author.getLastName())</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">                    &amp;&amp; StringUtils.equalsIgnoreCase(ctc.getFirstName(), author.getFirstName()))</span>
<span class="fc" id="L302">        .findFirst();</span>
  }

  /**
   * Given a {@link Contact}, generates a String for that contact for citation purpose. The
   * organization will be used (if present) in case we don't have both lastName and firstNames of
   * the contact.
   *
   * @param creator contact object
   * @return name
   */
  public static String getAuthorName(Contact creator) {
<span class="fc" id="L314">    StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L315">    String lastName = StringUtils.trimToNull(creator.getLastName());</span>
<span class="fc" id="L316">    String firstNames = StringUtils.trimToNull(creator.getFirstName());</span>
<span class="fc" id="L317">    String organization = StringUtils.trimToNull(creator.getOrganization());</span>

<span class="fc bfc" id="L319" title="All 4 branches covered.">    if (lastName != null &amp;&amp; firstNames != null) {</span>
<span class="fc" id="L320">      sb.append(lastName);</span>
<span class="fc" id="L321">      sb.append(&quot; &quot;);</span>
      // add first initial of each first name, capitalized
<span class="fc" id="L323">      String[] names = firstNames.split(&quot;\\s+&quot;);</span>

<span class="fc" id="L325">      sb.append(</span>
<span class="fc" id="L326">          Arrays.stream(names)</span>
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">              .filter(str -&gt; !StringUtils.isBlank(str))</span>
<span class="fc" id="L328">              .map(str -&gt; StringUtils.upperCase(String.valueOf(str.charAt(0))))</span>
<span class="fc" id="L329">              .collect(Collectors.joining(&quot; &quot;)));</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">    } else if (lastName != null) {</span>
<span class="fc" id="L331">      sb.append(lastName);</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">    } else if (organization != null) {</span>
<span class="fc" id="L333">      sb.append(organization);</span>
    }
<span class="fc" id="L335">    return sb.toString();</span>
  }

<span class="nc bnc" id="L338" title="All 22 branches missed.">  @Data</span>
<span class="pc" id="L339">  @Builder</span>
  public static class CitationData {

<span class="fc" id="L342">    private final Citation citation;</span>
<span class="fc" id="L343">    private final List&lt;CitationContact&gt; contacts;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>