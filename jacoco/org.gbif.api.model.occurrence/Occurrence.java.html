<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Occurrence.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common :: API</a> &gt; <a href="index.source.html" class="el_package">org.gbif.api.model.occurrence</a> &gt; <span class="el_source">Occurrence.java</span></div><h1>Occurrence.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014 Global Biodiversity Information Facility (GBIF)
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.api.model.occurrence;

import org.gbif.api.model.common.Identifier;
import org.gbif.api.model.common.LinneanClassification;
import org.gbif.api.model.common.LinneanClassificationKeys;
import org.gbif.api.model.common.MediaObject;
import org.gbif.api.util.ClassificationUtils;
import org.gbif.api.vocabulary.BasisOfRecord;
import org.gbif.api.vocabulary.Continent;
import org.gbif.api.vocabulary.Country;
import org.gbif.api.vocabulary.EstablishmentMeans;
import org.gbif.api.vocabulary.License;
import org.gbif.api.vocabulary.LifeStage;
import org.gbif.api.vocabulary.OccurrenceIssue;
import org.gbif.api.vocabulary.Rank;
import org.gbif.api.vocabulary.Sex;
import org.gbif.api.vocabulary.TaxonomicStatus;
import org.gbif.api.vocabulary.TypeStatus;
import org.gbif.dwc.terms.DwcTerm;
import org.gbif.dwc.terms.Term;
import org.gbif.dwc.terms.UnknownTerm;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.net.URI;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.EnumSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.annotation.Nullable;
import javax.validation.constraints.Max;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;

import com.google.common.base.Objects;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import org.codehaus.jackson.annotate.JsonAnyGetter;
import org.codehaus.jackson.annotate.JsonIgnore;
import org.codehaus.jackson.annotate.JsonProperty;
import org.codehaus.jackson.map.annotate.JsonDeserialize;
import org.codehaus.jackson.map.annotate.JsonSerialize;

/**
 * Represents an Occurrence as interpreted by GBIF, adding typed properties on top of the verbatim ones.
 */
public class Occurrence extends VerbatimOccurrence implements LinneanClassification, LinneanClassificationKeys {

  public static final String GEO_DATUM = &quot;WGS84&quot;;
  // keep names of ALL properties of this class in a set for jackson serialization, see #properties()
<span class="fc" id="L71">  private static final Set&lt;String&gt; PROPERTIES =  Collections.unmodifiableSet(</span>
<span class="fc" id="L72">    Stream.concat(</span>
      // we need to these json properties manually cause we have a fixed getter but no field for it
<span class="fc" id="L74">      Stream.of(DwcTerm.geodeticDatum.simpleName(), &quot;class&quot;, &quot;countryCode&quot;),</span>
<span class="fc" id="L75">      Stream.concat(Arrays.stream(Occurrence.class.getDeclaredFields()),</span>
<span class="fc" id="L76">                    Arrays.stream(VerbatimOccurrence.class.getDeclaredFields()))</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">                     .filter(field -&gt; !Modifier.isStatic(field.getModifiers()))</span>
<span class="fc" id="L78">                     .map(Field::getName)).collect(Collectors.toSet()));</span>
  // occurrence fields
  private BasisOfRecord basisOfRecord;
  private Integer individualCount;
  private Sex sex;
  private LifeStage lifeStage;
  private EstablishmentMeans establishmentMeans;
  // taxonomy as nub keys -&gt; LinneanClassificationKeys
  private Integer taxonKey;
  private Integer kingdomKey;
  private Integer phylumKey;
  private Integer classKey;
  private Integer orderKey;
  private Integer familyKey;
  private Integer genusKey;
  private Integer subgenusKey;
  private Integer speciesKey;
  private Integer acceptedTaxonKey;
  // taxonomy as name strings -&gt; LinneanClassification
  private String scientificName;  // the interpreted name matching taxonKey
  private String acceptedScientificName;
  private String kingdom;
  private String phylum;
  @JsonProperty(&quot;class&quot;)
  private String clazz;
  private String order;
  private String family;
  private String genus;
  private String subgenus;
  private String species;
  // atomised scientific name
  private String genericName; // missing from DwC
  private String specificEpithet;
  private String infraspecificEpithet;
  private Rank taxonRank;
  private TaxonomicStatus taxonomicStatus;
  // identification
  private Date dateIdentified;
  // location
  private Double decimalLongitude;
  private Double decimalLatitude;

  //coordinatePrecision and coordinateUncertaintyInMeters should be BigDecimal see POR-2795
  private Double coordinatePrecision;
  private Double coordinateUncertaintyInMeters;
  @Deprecated //see getter
  private Double coordinateAccuracy;

  private Double elevation;
  private Double elevationAccuracy;
  private Double depth;
  private Double depthAccuracy;
  private Continent continent;
  @JsonSerialize(using = Country.IsoSerializer.class)
  @JsonDeserialize(using = Country.IsoDeserializer.class)
  private Country country;
  private String stateProvince;
  private String waterBody;
  // recording event
  private Integer year;
  private Integer month;
  private Integer day;
  private Date eventDate;
  private TypeStatus typeStatus;
  // extracted from type status, but we should propose a new dwc term for this!
  // for example: &quot;Paratype of Taeniopteryx metequi Ricker &amp; Ross&quot; is status=Paratype, typifiedName=Taeniopteryx metequi
// Ricker &amp; Ross
  private String typifiedName; // missing from DwC
<span class="fc" id="L146">  private Set&lt;OccurrenceIssue&gt; issues = EnumSet.noneOf(OccurrenceIssue.class);</span>
  // record level
  private Date modified;  // interpreted dc:modified, i.e. date changed in source
  private Date lastInterpreted;
  private URI references;
  private License license;
  // interpreted extension data
<span class="fc" id="L153">  private List&lt;Identifier&gt; identifiers = Lists.newArrayList();</span>
<span class="fc" id="L154">  private List&lt;MediaObject&gt; media = Lists.newArrayList();</span>
<span class="fc" id="L155">  private List&lt;FactOrMeasurment&gt; facts = Lists.newArrayList();</span>
<span class="fc" id="L156">  private List&lt;OccurrenceRelation&gt; relations = Lists.newArrayList();</span>

<span class="fc" id="L158">  public Occurrence() {</span>

<span class="fc" id="L160">  }</span>

  /**
   * Create occurrence instance from existing verbatim one, copying over all data.
   */
<span class="fc" id="L165">  public Occurrence(@Nullable VerbatimOccurrence verbatim) {</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">    if (verbatim != null) {</span>
<span class="fc" id="L167">      setKey(verbatim.getKey());</span>
<span class="fc" id="L168">      setDatasetKey(verbatim.getDatasetKey());</span>
<span class="fc" id="L169">      setPublishingOrgKey(verbatim.getPublishingOrgKey());</span>
<span class="fc" id="L170">      setPublishingCountry(verbatim.getPublishingCountry());</span>
<span class="fc" id="L171">      setProtocol(verbatim.getProtocol());</span>
<span class="fc" id="L172">      setCrawlId(verbatim.getCrawlId());</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">      if (verbatim.getLastCrawled() != null) {</span>
<span class="fc" id="L174">        setLastCrawled(new Date(verbatim.getLastCrawled().getTime()));</span>
      }
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">      if (verbatim.getVerbatimFields() != null) {</span>
<span class="fc" id="L177">        getVerbatimFields().putAll(verbatim.getVerbatimFields());</span>
      }
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">      if (verbatim.getLastParsed() != null) {</span>
<span class="nc" id="L180">        setLastParsed(verbatim.getLastParsed());</span>
      }
<span class="fc" id="L182">      setExtensions(verbatim.getExtensions());</span>
    }
<span class="fc" id="L184">  }</span>

  @Nullable
  public BasisOfRecord getBasisOfRecord() {
<span class="fc" id="L188">    return basisOfRecord;</span>
  }

  public void setBasisOfRecord(BasisOfRecord basisOfRecord) {
<span class="fc" id="L192">    this.basisOfRecord = basisOfRecord;</span>
<span class="fc" id="L193">  }</span>

  @Nullable
  public Integer getIndividualCount() {
<span class="fc" id="L197">    return individualCount;</span>
  }

  public void setIndividualCount(Integer individualCount) {
<span class="nc" id="L201">    this.individualCount = individualCount;</span>
<span class="nc" id="L202">  }</span>

  @Nullable
  public Sex getSex() {
<span class="fc" id="L206">    return sex;</span>
  }

  public void setSex(Sex sex) {
<span class="nc" id="L210">    this.sex = sex;</span>
<span class="nc" id="L211">  }</span>

  @Nullable
  public LifeStage getLifeStage() {
<span class="fc" id="L215">    return lifeStage;</span>
  }

  public void setLifeStage(LifeStage lifeStage) {
<span class="nc" id="L219">    this.lifeStage = lifeStage;</span>
<span class="nc" id="L220">  }</span>

  @Nullable
  public EstablishmentMeans getEstablishmentMeans() {
<span class="fc" id="L224">    return establishmentMeans;</span>
  }

  public void setEstablishmentMeans(EstablishmentMeans establishmentMeans) {
<span class="nc" id="L228">    this.establishmentMeans = establishmentMeans;</span>
<span class="nc" id="L229">  }</span>

  @Nullable
  /**
   * The best matching, accepted GBIF backbone name usage representing this occurrence.
   * In case the verbatim scientific name and its classification can only be matched to a higher rank this will
   * represent the lowest matching rank. In the worst case this could just be for example Animalia.
   */
  public Integer getTaxonKey() {
<span class="fc" id="L238">    return taxonKey;</span>
  }

  public void setTaxonKey(Integer taxonKey) {
<span class="fc" id="L242">    this.taxonKey = taxonKey;</span>
<span class="fc" id="L243">  }</span>

  @Nullable
  @Override
  public Integer getKingdomKey() {
<span class="fc" id="L248">    return kingdomKey;</span>
  }

  @Override
  public void setKingdomKey(@Nullable Integer kingdomKey) {
<span class="fc" id="L253">    this.kingdomKey = kingdomKey;</span>
<span class="fc" id="L254">  }</span>

  @Nullable
  @Override
  public Integer getPhylumKey() {
<span class="fc" id="L259">    return phylumKey;</span>
  }

  @Override
  public void setPhylumKey(@Nullable Integer phylumKey) {
<span class="nc" id="L264">    this.phylumKey = phylumKey;</span>
<span class="nc" id="L265">  }</span>

  @Nullable
  @Override
  public Integer getClassKey() {
<span class="fc" id="L270">    return classKey;</span>
  }

  @Override
  public void setClassKey(@Nullable Integer classKey) {
<span class="fc" id="L275">    this.classKey = classKey;</span>
<span class="fc" id="L276">  }</span>

  @Nullable
  @Override
  public Integer getOrderKey() {
<span class="fc" id="L281">    return orderKey;</span>
  }

  @Override
  public void setOrderKey(@Nullable Integer orderKey) {
<span class="nc" id="L286">    this.orderKey = orderKey;</span>
<span class="nc" id="L287">  }</span>

  @Nullable
  @Override
  public Integer getFamilyKey() {
<span class="fc" id="L292">    return familyKey;</span>
  }

  @Override
  public void setFamilyKey(@Nullable Integer familyKey) {
<span class="fc" id="L297">    this.familyKey = familyKey;</span>
<span class="fc" id="L298">  }</span>

  @Nullable
  @Override
  public Integer getGenusKey() {
<span class="fc" id="L303">    return genusKey;</span>
  }

  @Override
  public void setGenusKey(@Nullable Integer genusKey) {
<span class="nc" id="L308">    this.genusKey = genusKey;</span>
<span class="nc" id="L309">  }</span>

  @Nullable
  @Override
  public Integer getSubgenusKey() {
<span class="fc" id="L314">    return subgenusKey;</span>
  }

  @Override
  public void setSubgenusKey(@Nullable Integer subgenusKey) {
<span class="nc" id="L319">    this.subgenusKey = subgenusKey;</span>
<span class="nc" id="L320">  }</span>

  @Nullable
  @Override
  public Integer getHigherRankKey(Rank rank) {
<span class="fc" id="L325">    return ClassificationUtils.getHigherRankKey(this, rank);</span>
  }

  /**
   * An ordered map with entries for all higher Linnean ranks excluding the taxonKey itself.
   * The map starts with the highest rank, e.g. the kingdom and maps the name usage key to its canonical name.
   *
   * @return map of higher ranks
   */
  @NotNull
  @JsonIgnore
  public LinkedHashMap&lt;Integer, String&gt; getHigherClassificationMap() {
<span class="fc bfc" id="L337" title="All 2 branches covered.">    return taxonKey == null ? ClassificationUtils.getHigherClassificationMap(this)</span>
<span class="fc" id="L338">      : ClassificationUtils.getHigherClassificationMap(this, taxonKey, null, null);</span>
  }

  @Nullable
  @Override
  /**
   * The accepted species for this occurrence. In case the taxonKey is of a higher rank than species (e.g. genus)
   * speciesKey is null. In case taxonKey represents an infraspecific taxon the speciesKey points to the species
   * the infraspecies is classified as. In case of taxonKey being a species the speciesKey is the same.
   */
  public Integer getSpeciesKey() {
<span class="fc" id="L349">    return speciesKey;</span>
  }

  @Override
  public void setSpeciesKey(@Nullable Integer speciesKey) {
<span class="nc" id="L354">    this.speciesKey = speciesKey;</span>
<span class="nc" id="L355">  }</span>

  @Nullable
  /**
   * The accepted taxon key from the GBIF backbone.
   */
  public Integer getAcceptedTaxonKey() {
<span class="fc" id="L362">    return acceptedTaxonKey;</span>
  }

  public void setAcceptedTaxonKey(Integer acceptedTaxonKey) {
<span class="nc" id="L366">    this.acceptedTaxonKey = acceptedTaxonKey;</span>
<span class="nc" id="L367">  }</span>

  @Nullable
  public String getSpecificEpithet() {
<span class="fc" id="L371">    return specificEpithet;</span>
  }

  public void setSpecificEpithet(String specificEpithet) {
<span class="nc" id="L375">    this.specificEpithet = specificEpithet;</span>
<span class="nc" id="L376">  }</span>

  @Nullable
  public String getInfraspecificEpithet() {
<span class="fc" id="L380">    return infraspecificEpithet;</span>
  }

  public void setInfraspecificEpithet(String infraspecificEpithet) {
<span class="nc" id="L384">    this.infraspecificEpithet = infraspecificEpithet;</span>
<span class="nc" id="L385">  }</span>

  @Nullable
  public Rank getTaxonRank() {
<span class="fc" id="L389">    return taxonRank;</span>
  }

  public void setTaxonRank(Rank taxonRank) {
<span class="nc" id="L393">    this.taxonRank = taxonRank;</span>
<span class="nc" id="L394">  }</span>

  /**
   * The status of the use of the scientificName as a label for a taxon.
   * The GBIF recommended controlled value vocabulary can be found at &lt;a href=&quot;http://rs.gbif.org/vocabulary/gbif/taxonomic_status.xm&quot;&gt;http://rs.gbif.org/vocabulary/gbif/taxonomic_status.xm&lt;/a&gt;.
   */
  @Nullable
  public TaxonomicStatus getTaxonomicStatus() {
<span class="fc" id="L402">    return taxonomicStatus;</span>
  }

  public void setTaxonomicStatus(TaxonomicStatus taxonomicStatus) {
<span class="nc" id="L406">    this.taxonomicStatus = taxonomicStatus;</span>
<span class="nc" id="L407">  }</span>

  @Nullable
  /**
   * The scientific name for taxonKey from the GBIF backbone.
   */
  public String getScientificName() {
<span class="fc" id="L414">    return scientificName;</span>
  }

  public void setScientificName(@Nullable String scientificName) {
<span class="fc" id="L418">    this.scientificName = scientificName;</span>
<span class="fc" id="L419">  }</span>

  @Nullable
  /**
   * The accepted scientific name for the acceptedTaxonKey from the GBIF backbone.
   */
  public String getAcceptedScientificName() {
<span class="fc" id="L426">    return acceptedScientificName;</span>
  }

  public void setAcceptedScientificName(String acceptedScientificName) {
<span class="nc" id="L430">    this.acceptedScientificName = acceptedScientificName;</span>
<span class="nc" id="L431">  }</span>

  @Nullable
  @Override
  public String getKingdom() {
<span class="fc" id="L436">    return kingdom;</span>
  }

  @Override
  public void setKingdom(@Nullable String kingdom) {
<span class="fc" id="L441">    this.kingdom = kingdom;</span>
<span class="fc" id="L442">  }</span>

  @Nullable
  @Override
  public String getPhylum() {
<span class="fc" id="L447">    return phylum;</span>
  }

  @Override
  public void setPhylum(@Nullable String phylum) {
<span class="nc" id="L452">    this.phylum = phylum;</span>
<span class="nc" id="L453">  }</span>

  @Nullable
  @Override
  public String getClazz() {
<span class="fc" id="L458">    return clazz;</span>
  }

  @Override
  public void setClazz(@Nullable String clazz) {
<span class="fc" id="L463">    this.clazz = clazz;</span>
<span class="fc" id="L464">  }</span>

  @Nullable
  @Override
  public String getOrder() {
<span class="fc" id="L469">    return order;</span>
  }

  @Override
  public void setOrder(@Nullable String order) {
<span class="nc" id="L474">    this.order = order;</span>
<span class="nc" id="L475">  }</span>

  @Nullable
  @Override
  public String getFamily() {
<span class="fc" id="L480">    return family;</span>
  }

  @Override
  public void setFamily(@Nullable String family) {
<span class="fc" id="L485">    this.family = family;</span>
<span class="fc" id="L486">  }</span>

  @Nullable
  @Override
  public String getGenus() {
<span class="fc" id="L491">    return genus;</span>
  }

  @Override
  public void setGenus(@Nullable String genus) {
<span class="nc" id="L496">    this.genus = genus;</span>
<span class="nc" id="L497">  }</span>

  @Nullable
  public String getGenericName() {
<span class="fc" id="L501">    return genericName;</span>
  }

  public void setGenericName(String genericName) {
<span class="nc" id="L505">    this.genericName = genericName;</span>
<span class="nc" id="L506">  }</span>

  @Nullable
  @Override
  public String getSubgenus() {
<span class="fc" id="L511">    return subgenus;</span>
  }

  @Override
  public void setSubgenus(@Nullable String subgenus) {
<span class="nc" id="L516">    this.subgenus = subgenus;</span>
<span class="nc" id="L517">  }</span>

  @Nullable
  @Override
  public String getHigherRank(Rank rank) {
<span class="fc" id="L522">    return ClassificationUtils.getHigherRank(this, rank);</span>
  }

  @Nullable
  @Override
  /**
   * The corresponding scientific name of the speciesKey from the GBIF backbone.
   */
  public String getSpecies() {
<span class="fc" id="L531">    return species;</span>
  }

  @Override
  public void setSpecies(@Nullable String species) {
<span class="nc" id="L536">    this.species = species;</span>
<span class="nc" id="L537">  }</span>

  @Nullable
  public Date getDateIdentified() {
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">    return dateIdentified == null ? null : new Date(dateIdentified.getTime());</span>
  }

  public void setDateIdentified(@Nullable Date dateIdentified) {
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">    this.dateIdentified = dateIdentified == null ? null : new Date(dateIdentified.getTime());</span>
<span class="fc" id="L546">  }</span>

  @Nullable
  /**
   * The decimalLongitude in decimal degrees always for the WGS84 datum. If a different geodetic datum was given the verbatim
   * coordinates are transformed into WGS84 values.
   */
  public Double getDecimalLongitude() {
<span class="fc" id="L554">    return decimalLongitude;</span>
  }

  public void setDecimalLongitude(@Nullable Double decimalLongitude) {
<span class="fc" id="L558">    this.decimalLongitude = decimalLongitude;</span>
<span class="fc" id="L559">  }</span>

  @Nullable
  public Double getDecimalLatitude() {
<span class="fc" id="L563">    return decimalLatitude;</span>
  }

  public void setDecimalLatitude(@Nullable Double decimalLatitude) {
<span class="fc" id="L567">    this.decimalLatitude = decimalLatitude;</span>
<span class="fc" id="L568">  }</span>

  /**
   * The uncertainty radius for lat/lon in meters.
   */
  @Nullable
  public Double getCoordinateUncertaintyInMeters() {
<span class="fc" id="L575">    return coordinateUncertaintyInMeters;</span>
  }

  public void setCoordinateUncertaintyInMeters(@Nullable Double coordinateUncertaintyInMeters) {
<span class="fc" id="L579">    this.coordinateUncertaintyInMeters = coordinateUncertaintyInMeters;</span>
<span class="fc" id="L580">  }</span>

  @Nullable
  public Double getCoordinatePrecision() {
<span class="fc" id="L584">    return coordinatePrecision;</span>
  }

  public void setCoordinatePrecision(Double coordinatePrecision) {
<span class="nc" id="L588">    this.coordinatePrecision = coordinatePrecision;</span>
<span class="nc" id="L589">  }</span>

  @Nullable
  @Deprecated
  /**
   * @Deprecated to be removed in the public v2 of the API (see POR-3061)
   * The uncertainty for latitude in decimal degrees.
   * Note that the longitude degrees have a different accuracy in degrees which changes with latitude and is largest at the poles.
   */
  public Double getCoordinateAccuracy() {
<span class="fc" id="L599">    return coordinateAccuracy;</span>
  }

  public void setCoordinateAccuracy(@Nullable Double coordinateAccuracy) {
<span class="fc" id="L603">    this.coordinateAccuracy = coordinateAccuracy;</span>
<span class="fc" id="L604">  }</span>

  /**
   * The geodetic datum for the interpreted decimal coordinates.
   * This is always WGS84 if there a coordinate exists as we reproject other datums into WGS84.
   */
  @Nullable
  public String getGeodeticDatum() {
<span class="fc bfc" id="L612" title="All 2 branches covered.">    if (decimalLatitude != null) {</span>
<span class="fc" id="L613">      return GEO_DATUM;</span>
    }
<span class="fc" id="L615">    return null;</span>
  }

  /**
   * This private method is needed for jackson deserialization only.
   */
  private void setGeodeticDatum(String datum) {
    // ignore, we have a static WGS84 value
<span class="fc" id="L623">  }</span>


  @Nullable
  /**
   * Elevation in meters usually above sea level (altitude).
   * &lt;/br&gt;
   * The elevation is calculated using the equation: (minimumElevationInMeters + maximumElevationInMeters) / 2.
   */
  public Double getElevation() {
<span class="fc" id="L633">    return elevation;</span>
  }

  public void setElevation(@Nullable Double elevation) {
<span class="nc" id="L637">    this.elevation = elevation;</span>
<span class="nc" id="L638">  }</span>

  /**
   * Elevation accuracy is the uncertainty for the elevation in meters.
   * &lt;/br&gt;
   * The elevation accuracy is calculated using the equation: (maximumElevationInMeters - minimumElevationInMeters) / 2
   */
  @Nullable
  public Double getElevationAccuracy() {
<span class="fc" id="L647">    return elevationAccuracy;</span>
  }

  public void setElevationAccuracy(@Nullable Double elevationAccuracy) {
<span class="nc" id="L651">    this.elevationAccuracy = elevationAccuracy;</span>
<span class="nc" id="L652">  }</span>

  @Nullable
  /**
   * Depth in meters below the surface. Complimentary to elevation, the depth can be 10 meters below the surface of a
   * lake in 1100m (=elevation).
   * &lt;/br&gt;
   * The depth is calculated using the equation: (minimumDepthInMeters + maximumDepthInMeters) / 2.
   */
  public Double getDepth() {
<span class="fc" id="L662">    return depth;</span>
  }

  public void setDepth(@Nullable Double depth) {
<span class="nc" id="L666">    this.depth = depth;</span>
<span class="nc" id="L667">  }</span>

  /**
   * Depth accuracy is the uncertainty for the depth in meters.
   * &lt;/br&gt;
   * The depth accuracy is calculated using the equation: (maximumDepthInMeters - minimumDepthInMeters) / 2
   */
  @Nullable
  public Double getDepthAccuracy() {
<span class="fc" id="L676">    return depthAccuracy;</span>
  }

  public void setDepthAccuracy(@Nullable Double depthAccuracy) {
<span class="nc" id="L680">    this.depthAccuracy = depthAccuracy;</span>
<span class="nc" id="L681">  }</span>

  @Nullable
  public Continent getContinent() {
<span class="fc" id="L685">    return continent;</span>
  }

  public void setContinent(@Nullable Continent continent) {
<span class="fc" id="L689">    this.continent = continent;</span>
<span class="fc" id="L690">  }</span>

  @Nullable
  @JsonProperty(&quot;countryCode&quot;)
  public Country getCountry() {
<span class="fc" id="L695">    return country;</span>
  }

  public void setCountry(@Nullable Country country) {
<span class="fc" id="L699">    this.country = country;</span>
<span class="fc" id="L700">  }</span>

  /**
   * Renders the country title as json property country in addition to the iso 2 letter countryCode being
   * serialized by the regular country java property.
   * Made private to only use it for json serialization and not within java code.
   */
  @Nullable
  @JsonProperty(&quot;country&quot;)
  private String getCountryTitle() {
<span class="fc bfc" id="L710" title="All 2 branches covered.">    return country == null ? null : country.getTitle();</span>
  }

  private void setCountryTitle(String country) {
    // ignore, setter only to avoid json being written into the fields map
<span class="fc" id="L715">  }</span>

  @Nullable
  public String getStateProvince() {
<span class="fc" id="L719">    return stateProvince;</span>
  }

  public void setStateProvince(@Nullable String stateProvince) {
<span class="nc" id="L723">    this.stateProvince = stateProvince;</span>
<span class="nc" id="L724">  }</span>

  @Nullable
  public String getWaterBody() {
<span class="fc" id="L728">    return waterBody;</span>
  }

  public void setWaterBody(@Nullable String waterBody) {
<span class="nc" id="L732">    this.waterBody = waterBody;</span>
<span class="nc" id="L733">  }</span>

  /**
   * The full year of the event date.
   *
   * @return the year of the event date
   */
  @Min(1500)
  @Max(2020)
  @Nullable
  public Integer getYear() {
<span class="fc" id="L744">    return year;</span>
  }

  public void setYear(@Nullable Integer year) {
<span class="fc" id="L748">    this.year = year;</span>
<span class="fc" id="L749">  }</span>

  /**
   * The month of the year of the event date starting with zero for january following {@link Date}.
   *
   * @return the month of the event date
   */
  @Min(1)
  @Max(12)
  @Nullable
  public Integer getMonth() {
<span class="fc" id="L760">    return month;</span>
  }

  public void setMonth(@Nullable Integer month) {
<span class="fc" id="L764">    this.month = month;</span>
<span class="fc" id="L765">  }</span>

  /**
   * The day of the month of the event date.
   *
   * @return the day of the event date
   */
  @Min(1)
  @Max(31)
  @Nullable
  public Integer getDay() {
<span class="fc" id="L776">    return day;</span>
  }

  public void setDay(@Nullable Integer day) {
<span class="fc" id="L780">    this.day = day;</span>
<span class="fc" id="L781">  }</span>

  @Nullable
  /**
   * The date the occurrence was recorded or collected.
   */
  public Date getEventDate() {
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">    return eventDate == null ? null : new Date(eventDate.getTime());</span>
  }

  public void setEventDate(@Nullable Date eventDate) {
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">    this.eventDate = eventDate == null ? null : new Date(eventDate.getTime());</span>
<span class="fc" id="L793">  }</span>

  @Nullable
  public TypeStatus getTypeStatus() {
<span class="fc" id="L797">    return typeStatus;</span>
  }

  public void setTypeStatus(@Nullable TypeStatus typeStatus) {
<span class="nc" id="L801">    this.typeStatus = typeStatus;</span>
<span class="nc" id="L802">  }</span>

  @Nullable
  /**
   * The scientific name the type status of this specimen applies to.
   */
  public String getTypifiedName() {
<span class="fc" id="L809">    return typifiedName;</span>
  }

  public void setTypifiedName(@Nullable String typifiedName) {
<span class="nc" id="L813">    this.typifiedName = typifiedName;</span>
<span class="nc" id="L814">  }</span>

  @NotNull
  /**
   * A set of issues found for this occurrence.
   */
  public Set&lt;OccurrenceIssue&gt; getIssues() {
<span class="fc" id="L821">    return issues;</span>
  }

  public void setIssues(Set&lt;OccurrenceIssue&gt; issues) {
<span class="fc" id="L825">    Preconditions.checkNotNull(&quot;Issues cannot be null&quot;, issues);</span>
<span class="fc" id="L826">    this.issues = Sets.newEnumSet(issues, OccurrenceIssue.class);</span>
<span class="fc" id="L827">  }</span>

  public void addIssue(OccurrenceIssue issue) {
<span class="fc" id="L830">    Preconditions.checkNotNull(&quot;Issue needs to be specified&quot;, issue);</span>
<span class="fc" id="L831">    issues.add(issue);</span>
<span class="fc" id="L832">  }</span>

  @Nullable
  /**
   * The interpreted dc:modified from the verbatim source data.
   * Ideally indicating when a record was last modified in the source.
   */
  public Date getModified() {
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">    return modified == null ? null : new Date(modified.getTime());</span>
  }

  public void setModified(@Nullable Date modified) {
<span class="pc bpc" id="L844" title="1 of 2 branches missed.">    this.modified = modified == null ? null : new Date(modified.getTime());</span>
<span class="fc" id="L845">  }</span>

  @Nullable
  /**
   * The date this occurrence last went through the interpretation phase of the GBIF indexing.
   */
  public Date getLastInterpreted() {
<span class="pc bpc" id="L852" title="1 of 2 branches missed.">    return lastInterpreted == null ? null : new Date(lastInterpreted.getTime());</span>
  }

  public void setLastInterpreted(@Nullable Date lastInterpreted) {
<span class="fc bfc" id="L856" title="All 2 branches covered.">    this.lastInterpreted = lastInterpreted == null ? null : new Date(lastInterpreted.getTime());</span>
<span class="fc" id="L857">  }</span>

  @Nullable
  /**
   * An external link to more details, the records &quot;homepage&quot;.
   */
  public URI getReferences() {
<span class="fc" id="L864">    return references;</span>
  }

  public void setReferences(URI references) {
<span class="nc" id="L868">    this.references = references;</span>
<span class="nc" id="L869">  }</span>

  /**
   * Applied license to the occurrence record or dataset to which this record belongs to.
   */
  @NotNull
  public License getLicense() {
<span class="fc" id="L876">    return license;</span>
  }

  public void setLicense(License license) {
<span class="nc" id="L880">    this.license = license;</span>
<span class="nc" id="L881">  }</span>

  @NotNull
  public List&lt;Identifier&gt; getIdentifiers() {
<span class="fc" id="L885">    return identifiers;</span>
  }

  public void setIdentifiers(List&lt;Identifier&gt; identifiers) {
<span class="fc" id="L889">    this.identifiers = identifiers;</span>
<span class="fc" id="L890">  }</span>

  @NotNull
  public List&lt;MediaObject&gt; getMedia() {
<span class="fc" id="L894">    return media;</span>
  }

  public void setMedia(List&lt;MediaObject&gt; media) {
<span class="fc" id="L898">    this.media = media;</span>
<span class="fc" id="L899">  }</span>

  @NotNull
  public List&lt;FactOrMeasurment&gt; getFacts() {
<span class="fc" id="L903">    return facts;</span>
  }

  public void setFacts(List&lt;FactOrMeasurment&gt; facts) {
<span class="fc" id="L907">    this.facts = facts;</span>
<span class="fc" id="L908">  }</span>

  @NotNull
  public List&lt;OccurrenceRelation&gt; getRelations() {
<span class="fc" id="L912">    return relations;</span>
  }

  public void setRelations(List&lt;OccurrenceRelation&gt; relations) {
<span class="fc" id="L916">    this.relations = relations;</span>
<span class="fc" id="L917">  }</span>


  @JsonIgnore
  /**
   * Convenience method checking if any spatial validation rule has not passed.
   * Primarily used to indicate that the record should not be displayed on a map.
   */
  public boolean hasSpatialIssue() {
<span class="fc bfc" id="L926" title="All 2 branches covered.">    for (OccurrenceIssue rule : OccurrenceIssue.GEOSPATIAL_RULES) {</span>
<span class="fc bfc" id="L927" title="All 2 branches covered.">      if (issues.contains(rule)) {</span>
<span class="fc" id="L928">        return true;</span>
      }
<span class="fc" id="L930">    }</span>
<span class="fc" id="L931">    return false;</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L936">    return Objects</span>
<span class="fc" id="L937">      .hashCode(basisOfRecord, individualCount, sex, lifeStage, establishmentMeans, taxonKey, kingdomKey, phylumKey,</span>
        classKey, orderKey, familyKey, genusKey, subgenusKey, speciesKey, scientificName, kingdom, phylum, clazz,
        order, family, genus, subgenus, species, genericName, specificEpithet, infraspecificEpithet, taxonRank,
        dateIdentified, year, month, day, eventDate, decimalLongitude, decimalLatitude, coordinatePrecision,
        coordinateUncertaintyInMeters, elevation, elevationAccuracy, depth, depthAccuracy,
        continent, country, stateProvince, waterBody, typeStatus, typifiedName, issues, modified,
        lastInterpreted, references, identifiers, media, facts, relations, license);
  }

  @Override
  public boolean equals(Object obj) {
<span class="fc bfc" id="L948" title="All 2 branches covered.">    if (this == obj) {</span>
<span class="fc" id="L949">      return true;</span>
    }
<span class="pc bpc" id="L951" title="1 of 2 branches missed.">    if (!(obj instanceof Occurrence)) {</span>
<span class="nc" id="L952">      return false;</span>
    }
<span class="pc bpc" id="L954" title="1 of 2 branches missed.">    if (!super.equals(obj)) {</span>
<span class="nc" id="L955">      return false;</span>
    }
<span class="fc" id="L957">    Occurrence that = (Occurrence) obj;</span>
<span class="pc bpc" id="L958" title="1 of 2 branches missed.">    return Objects.equal(this.basisOfRecord, that.basisOfRecord)</span>
<span class="pc bpc" id="L959" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.individualCount, that.individualCount)</span>
<span class="pc bpc" id="L960" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.sex, that.sex)</span>
<span class="pc bpc" id="L961" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.lifeStage, that.lifeStage)</span>
<span class="pc bpc" id="L962" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.establishmentMeans, that.establishmentMeans)</span>
<span class="pc bpc" id="L963" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.taxonKey, that.taxonKey)</span>
<span class="pc bpc" id="L964" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.kingdomKey, that.kingdomKey)</span>
<span class="pc bpc" id="L965" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.phylumKey, that.phylumKey)</span>
<span class="pc bpc" id="L966" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.classKey, that.classKey)</span>
<span class="pc bpc" id="L967" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.orderKey, that.orderKey)</span>
<span class="pc bpc" id="L968" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.familyKey, that.familyKey)</span>
<span class="pc bpc" id="L969" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.genusKey, that.genusKey)</span>
<span class="pc bpc" id="L970" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.subgenusKey, that.subgenusKey)</span>
<span class="pc bpc" id="L971" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.speciesKey, that.speciesKey)</span>
<span class="pc bpc" id="L972" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.acceptedTaxonKey, that.acceptedTaxonKey)</span>
<span class="pc bpc" id="L973" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.acceptedScientificName, that.acceptedScientificName)</span>
<span class="pc bpc" id="L974" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.scientificName, that.scientificName)</span>
<span class="pc bpc" id="L975" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.kingdom, that.kingdom)</span>
<span class="pc bpc" id="L976" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.phylum, that.phylum)</span>
<span class="pc bpc" id="L977" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.clazz, that.clazz)</span>
<span class="pc bpc" id="L978" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.order, that.order)</span>
<span class="pc bpc" id="L979" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.family, that.family)</span>
<span class="pc bpc" id="L980" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.genus, that.genus)</span>
<span class="pc bpc" id="L981" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.subgenus, that.subgenus)</span>
<span class="pc bpc" id="L982" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.species, that.species)</span>
<span class="pc bpc" id="L983" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.genericName, that.genericName)</span>
<span class="pc bpc" id="L984" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.specificEpithet, that.specificEpithet)</span>
<span class="pc bpc" id="L985" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.infraspecificEpithet, that.infraspecificEpithet)</span>
<span class="pc bpc" id="L986" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.taxonRank, that.taxonRank)</span>
<span class="pc bpc" id="L987" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.taxonomicStatus, that.taxonomicStatus)</span>
<span class="pc bpc" id="L988" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.dateIdentified, that.dateIdentified)</span>
<span class="pc bpc" id="L989" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.year, that.year)</span>
<span class="pc bpc" id="L990" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.month, that.month)</span>
<span class="pc bpc" id="L991" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.day, that.day)</span>
<span class="pc bpc" id="L992" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.eventDate, that.eventDate)</span>
<span class="pc bpc" id="L993" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.decimalLongitude, that.decimalLongitude)</span>
<span class="pc bpc" id="L994" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.decimalLatitude, that.decimalLatitude)</span>
<span class="pc bpc" id="L995" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.coordinatePrecision, that.coordinatePrecision)</span>
<span class="pc bpc" id="L996" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.coordinateUncertaintyInMeters, that.coordinateUncertaintyInMeters)</span>
<span class="pc bpc" id="L997" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.elevation, that.elevation)</span>
<span class="pc bpc" id="L998" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.elevationAccuracy, that.elevationAccuracy)</span>
<span class="pc bpc" id="L999" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.depth, that.depth)</span>
<span class="pc bpc" id="L1000" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.depthAccuracy, that.depthAccuracy)</span>
<span class="pc bpc" id="L1001" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.continent, that.continent)</span>
<span class="fc bfc" id="L1002" title="All 2 branches covered.">      &amp;&amp; Objects.equal(this.country, that.country)</span>
<span class="pc bpc" id="L1003" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.stateProvince, that.stateProvince)</span>
<span class="pc bpc" id="L1004" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.waterBody, that.waterBody)</span>
<span class="pc bpc" id="L1005" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.typeStatus, that.typeStatus)</span>
<span class="pc bpc" id="L1006" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.typifiedName, that.typifiedName)</span>
<span class="pc bpc" id="L1007" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.issues, that.issues)</span>
<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.modified, that.modified)</span>
<span class="pc bpc" id="L1009" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.lastInterpreted, that.lastInterpreted)</span>
<span class="pc bpc" id="L1010" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.references, that.references)</span>
<span class="pc bpc" id="L1011" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.identifiers, that.identifiers)</span>
<span class="pc bpc" id="L1012" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.media, that.media)</span>
<span class="pc bpc" id="L1013" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.facts, that.facts)</span>
<span class="pc bpc" id="L1014" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.relations, that.relations)</span>
<span class="pc bpc" id="L1015" title="1 of 2 branches missed.">      &amp;&amp; Objects.equal(this.license, that.license);</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L1020">    return super.toString() + Objects.toStringHelper(this)</span>
<span class="nc" id="L1021">      .add(&quot;basisOfRecord&quot;, basisOfRecord)</span>
<span class="nc" id="L1022">      .add(&quot;individualCount&quot;, individualCount)</span>
<span class="nc" id="L1023">      .add(&quot;sex&quot;, sex)</span>
<span class="nc" id="L1024">      .add(&quot;lifeStage&quot;, lifeStage)</span>
<span class="nc" id="L1025">      .add(&quot;establishmentMeans&quot;, establishmentMeans)</span>
<span class="nc" id="L1026">      .add(&quot;taxonKey&quot;, taxonKey)</span>
<span class="nc" id="L1027">      .add(&quot;kingdomKey&quot;, kingdomKey)</span>
<span class="nc" id="L1028">      .add(&quot;phylumKey&quot;, phylumKey)</span>
<span class="nc" id="L1029">      .add(&quot;classKey&quot;, classKey)</span>
<span class="nc" id="L1030">      .add(&quot;orderKey&quot;, orderKey)</span>
<span class="nc" id="L1031">      .add(&quot;familyKey&quot;, familyKey)</span>
<span class="nc" id="L1032">      .add(&quot;genusKey&quot;, genusKey)</span>
<span class="nc" id="L1033">      .add(&quot;subgenusKey&quot;, subgenusKey)</span>
<span class="nc" id="L1034">      .add(&quot;speciesKey&quot;, speciesKey)</span>
<span class="nc" id="L1035">      .add(&quot;acceptedTaxonKey&quot;, acceptedTaxonKey)</span>
<span class="nc" id="L1036">      .add(&quot;acceptedScientificName&quot;, acceptedScientificName)</span>
<span class="nc" id="L1037">      .add(&quot;kingdom&quot;, kingdom)</span>
<span class="nc" id="L1038">      .add(&quot;phylum&quot;, phylum)</span>
<span class="nc" id="L1039">      .add(&quot;clazz&quot;, clazz)</span>
<span class="nc" id="L1040">      .add(&quot;order&quot;, order)</span>
<span class="nc" id="L1041">      .add(&quot;family&quot;, family)</span>
<span class="nc" id="L1042">      .add(&quot;genus&quot;, genus)</span>
<span class="nc" id="L1043">      .add(&quot;subgenus&quot;, subgenus)</span>
<span class="nc" id="L1044">      .add(&quot;species&quot;, species)</span>
<span class="nc" id="L1045">      .add(&quot;genericName&quot;, genericName)</span>
<span class="nc" id="L1046">      .add(&quot;specificEpithet&quot;, specificEpithet)</span>
<span class="nc" id="L1047">      .add(&quot;infraspecificEpithet&quot;, infraspecificEpithet)</span>
<span class="nc" id="L1048">      .add(&quot;taxonRank&quot;, taxonRank)</span>
<span class="nc" id="L1049">      .add(&quot;taxonomicStatus&quot;, taxonomicStatus)</span>
<span class="nc" id="L1050">      .add(&quot;dateIdentified&quot;, dateIdentified)</span>
<span class="nc" id="L1051">      .add(&quot;decimalLongitude&quot;, decimalLongitude)</span>
<span class="nc" id="L1052">      .add(&quot;decimalLatitude&quot;, decimalLatitude)</span>
<span class="nc" id="L1053">      .add(&quot;coordinatePrecision&quot;, coordinatePrecision)</span>
<span class="nc" id="L1054">      .add(&quot;coordinateUncertaintyInMeters&quot;, coordinateUncertaintyInMeters)</span>
<span class="nc" id="L1055">      .add(&quot;coordinateAccuracy&quot;, coordinateAccuracy)</span>
<span class="nc" id="L1056">      .add(&quot;elevation&quot;, elevation)</span>
<span class="nc" id="L1057">      .add(&quot;elevationAccuracy&quot;, elevationAccuracy)</span>
<span class="nc" id="L1058">      .add(&quot;depth&quot;, depth)</span>
<span class="nc" id="L1059">      .add(&quot;depthAccuracy&quot;, depthAccuracy)</span>
<span class="nc" id="L1060">      .add(&quot;continent&quot;, continent)</span>
<span class="nc" id="L1061">      .add(&quot;country&quot;, country)</span>
<span class="nc" id="L1062">      .add(&quot;stateProvince&quot;, stateProvince)</span>
<span class="nc" id="L1063">      .add(&quot;waterBody&quot;, waterBody)</span>
<span class="nc" id="L1064">      .add(&quot;year&quot;, year)</span>
<span class="nc" id="L1065">      .add(&quot;month&quot;, month)</span>
<span class="nc" id="L1066">      .add(&quot;day&quot;, day)</span>
<span class="nc" id="L1067">      .add(&quot;eventDate&quot;, eventDate)</span>
<span class="nc" id="L1068">      .add(&quot;typeStatus&quot;, typeStatus)</span>
<span class="nc" id="L1069">      .add(&quot;typifiedName&quot;, typifiedName)</span>
<span class="nc" id="L1070">      .add(&quot;issues&quot;, issues)</span>
<span class="nc" id="L1071">      .add(&quot;modified&quot;, modified)</span>
<span class="nc" id="L1072">      .add(&quot;lastInterpreted&quot;, lastInterpreted)</span>
<span class="nc" id="L1073">      .add(&quot;references&quot;, references)</span>
<span class="nc" id="L1074">      .add(&quot;license&quot;, license)</span>
<span class="nc" id="L1075">      .toString();</span>
  }

  /**
   * This private method is only for serialization via jackson and not exposed anywhere else!
   * It maps the verbatimField terms into properties with their simple name or qualified names for UnknownTerms.
   */
  @JsonAnyGetter
  private Map&lt;String, String&gt; jsonVerbatimFields() {
<span class="fc" id="L1084">    Map&lt;String, String&gt; extendedProps = Maps.newHashMap();</span>
<span class="fc bfc" id="L1085" title="All 2 branches covered.">    for (Map.Entry&lt;Term, String&gt; prop : getVerbatimFields().entrySet()) {</span>
<span class="fc" id="L1086">      Term t = prop.getKey();</span>
<span class="fc bfc" id="L1087" title="All 4 branches covered.">      if (t instanceof UnknownTerm || PROPERTIES.contains(t.simpleName())) {</span>
<span class="fc" id="L1088">        extendedProps.put(t.qualifiedName(), prop.getValue());</span>
      } else {
        // render all terms in controlled enumerations as simple names only - unless we have a property of that name already!
<span class="fc" id="L1091">        extendedProps.put(t.simpleName(), prop.getValue());</span>
      }
<span class="fc" id="L1093">    }</span>
<span class="fc" id="L1094">    return extendedProps;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>