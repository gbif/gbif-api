<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DOI.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GBIF Common :: API</a> &gt; <a href="index.source.html" class="el_package">org.gbif.api.model.common</a> &gt; <span class="el_source">DOI.java</span></div><h1>DOI.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2020 Global Biodiversity Information Facility (GBIF)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.api.model.common;

import java.io.IOException;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URLEncoder;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.validation.constraints.NotNull;

import io.swagger.v3.oas.annotations.media.Schema;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;

import static org.gbif.api.util.PreconditionUtils.checkArgument;

/**
 * Class representing a single Digital Object Identifier (DOI) breaking it down to a prefix and suffix.
 * For the syntax of DOI names see the &lt;a href=&quot;http://www.doi.org/doi_handbook/2_Numbering.html#2.2&quot;&gt;DOI Handbook&lt;/a&gt;.
 * All parsing is case-insensitive and resulting components will all be uppercased.
 */
@Schema(
  description = &quot;A Digital Object Identifier (DOI).&quot;,
  pattern = &quot;(10[.][0-9]{2,}(?:[.][0-9]+)*/(?:(?![%\&quot;#? ])\\\\S)+)&quot;,
  example = &quot;10.15468/igasai&quot;,
  implementation = String.class
)
@JsonSerialize(using = DOI.DoiSerializer.class)
@JsonDeserialize(using = DOI.DoiDeserializer.class)
public class DOI implements Serializable {

<span class="fc" id="L61">  private static final Logger LOG = LoggerFactory.getLogger(DOI.class);</span>

  /**
   * Encoding to create URLs.
   */
  private static final String CHAR_ENCODING = &quot;UTF-8&quot;;

  /**
   * The DOI prefix registered with DataCite to be used by GBIF-issued production DOIs.
   */
  public static final String GBIF_PREFIX = &quot;10.15468&quot;;

  /**
   * A DOI prefix provided by DataCite to be used in tests.
   */
  public static final String TEST_PREFIX = &quot;10.21373&quot;;

<span class="fc" id="L78">  private static final Pattern HTTP = Pattern.compile(&quot;^https?://(dx\\.)?doi\\.org/&quot;</span>
    + &quot;(urn:)?(doi:)?&quot;, Pattern.CASE_INSENSITIVE);
<span class="fc" id="L80">  private static final Pattern PARSER = Pattern.compile(&quot;^(?:urn:)?(?:doi:)?&quot;           // optional</span>
    + &quot;(10(?:\\.[0-9]+)+)&quot;
    + &quot;/(.+)$&quot;, Pattern.CASE_INSENSITIVE);

  private static final String RESOLVER = &quot;https://doi.org/&quot;;
  private static final String SCHEME = &quot;doi:&quot;;
  private String prefix;
  private String suffix;

  /**
   * Returns true only if the source can be parsed into a DOI.
   */
  public static boolean isParsable(String source) {
<span class="fc bfc" id="L93" title="All 2 branches covered.">    if (StringUtils.isNotEmpty(source)) {</span>
      try {
<span class="fc" id="L95">        return PARSER.matcher(decodeUrl(source)).find();</span>
<span class="nc" id="L96">      } catch (IllegalArgumentException iaEx) {</span>
<span class="nc" id="L97">        LOG.debug(&quot;Can not decode URL from the following DOI: {}&quot;, source);</span>
      }
    }
<span class="fc" id="L100">    return false;</span>
  }

  /**
   * Do not use this constructor.
   * Required by JAXB to marshall this object without introducing adapters.
   */
<span class="nc" id="L107">  public DOI() {</span>
<span class="nc" id="L108">  }</span>

  /**
   * Parses a simple DOI string of various forms incl URN, URL or plain DOI names.
   *
   * @param doi the full simple DOI string
   * @throws java.lang.IllegalArgumentException if invalid DOI string is passed
   */
<span class="fc" id="L116">  public DOI(String doi) {</span>
<span class="fc" id="L117">    Objects.requireNonNull(doi, &quot;DOI required&quot;);</span>
<span class="fc" id="L118">    Matcher m = PARSER.matcher(decodeUrl(doi));</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">    if (m.find()) {</span>
<span class="fc" id="L120">      this.prefix = m.group(1).toLowerCase();</span>
<span class="fc" id="L121">      this.suffix = m.group(2).toLowerCase();</span>
    } else {
<span class="fc" id="L123">      throw new IllegalArgumentException(doi + &quot; is not a valid DOI&quot;);</span>
    }
<span class="fc" id="L125">  }</span>

  /**
   * Parses a simple DOI string of various forms incl URN, URL or plain DOI names.
   *
   * @param prefix a simple DOI prefix starting with 10.
   * @param suffix arbitrary suffix part of the DOI
   * @throws java.lang.IllegalArgumentException if invalid DOI prefix is given
   */
<span class="fc" id="L134">  public DOI(String prefix, String suffix) {</span>
<span class="fc" id="L135">    this.prefix = Objects.requireNonNull(prefix, &quot;DOI prefix required&quot;).toLowerCase();</span>
<span class="fc" id="L136">    checkArgument(prefix.startsWith(&quot;10.&quot;));</span>
<span class="fc" id="L137">    this.suffix = Objects.requireNonNull(suffix, &quot;DOI suffix required&quot;).toLowerCase();</span>
<span class="fc" id="L138">  }</span>

  /**
   * If the doi is encoded as a URL this method strips the resolver and decodes the URL encoded string entities.
   *
   * @param doi not null doi represented as a String
   * @return the path part if the doi is a URL otherwise the doi is returned as is.
   * @throws IllegalArgumentException
   */
  private static String decodeUrl(@NotNull String doi) {
<span class="fc" id="L148">    Matcher m = HTTP.matcher(doi);</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">    if (m.find()) {</span>
      // strip resolver incl potentially starting paths using a badly encoded urn:doi
      // (the colon would need to be encoded in a proper URL)
<span class="fc" id="L152">      doi = m.replaceFirst(&quot;&quot;);</span>
      // now decode the URL path, we cannot possibly have query parameters or anchors as the DOIs encoded as a URL
      // will just be a path
      try {
<span class="fc" id="L156">        return URI.create(URLEncoder.encode(doi, CHAR_ENCODING)).getPath();</span>
<span class="nc" id="L157">      } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L158">        throw new IllegalArgumentException(&quot;Unsupported DOI encoding&quot;, e);</span>
      }
    }
<span class="fc" id="L161">    return doi;</span>
  }

  public String getPrefix() {
<span class="nc" id="L165">    return prefix;</span>
  }

  public void setPrefix(String prefix) {
<span class="nc" id="L169">    this.prefix = prefix;</span>
<span class="nc" id="L170">  }</span>

  public String getSuffix() {
<span class="fc" id="L173">    return suffix;</span>
  }

  public void setSuffix(String suffix) {
<span class="nc" id="L177">    this.suffix = suffix;</span>
<span class="nc" id="L178">  }</span>

  /**
   * See &lt;a href=&quot;http://www.doi.org/doi_handbook/2_Numbering.html#2.6&quot;&gt;DOI Handbook, Visual presentation and other representation of DOI names&lt;/a&gt;.
   *
   * @return the resolved DOI using https://doi.org/
   * @throws IllegalStateException if the encoding of the DOI is not supported
   */
  public URI getUrl() {
    try {
<span class="fc" id="L188">      return URI.create(RESOLVER + prefix + '/' + URLEncoder.encode(suffix, CHAR_ENCODING));</span>
<span class="nc" id="L189">    } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L190">      throw new IllegalStateException(&quot;Unsupported DOI encoding&quot;, e);</span>
    }
  }

  /**
   * @return the DOI name prefixed with &quot;doi:&quot;, as recommended by the DOI Handbook.
   */
  public String getDoiString() {
<span class="nc" id="L198">    return SCHEME + getDoiName();</span>
  }

  /**
   * @return the pure DOI name without any initial scheme name starting with the prefix, i.e. 10.
   */
  public String getDoiName() {
<span class="fc" id="L205">    return prefix + '/' + suffix;</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L210">    return getDoiName();</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L215">    return Objects.hash(prefix, suffix);</span>
  }

  @Override
  public boolean equals(Object obj) {
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">    if (this == obj) {</span>
<span class="nc" id="L221">      return true;</span>
    }
<span class="pc bpc" id="L223" title="2 of 4 branches missed.">    if (obj == null || getClass() != obj.getClass()) {</span>
<span class="nc" id="L224">      return false;</span>
    }
<span class="fc" id="L226">    final DOI other = (DOI) obj;</span>
    // prefix and suffix are always uppercased so we can do simple equals here
<span class="pc bpc" id="L228" title="2 of 4 branches missed.">    return Objects.equals(this.prefix, other.prefix) &amp;&amp; Objects.equals(this.suffix, other.suffix);</span>
  }

<span class="fc" id="L231">  public static class DoiSerializer extends JsonSerializer&lt;DOI&gt; {</span>

    @Override
    public void serialize(DOI value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
<span class="fc" id="L235">      gen.writeString(value.toString());</span>
<span class="fc" id="L236">    }</span>
  }

<span class="fc" id="L239">  public static class DoiDeserializer extends JsonDeserializer&lt;DOI&gt; {</span>

    @Override
    public DOI deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
<span class="pc bpc" id="L243" title="2 of 4 branches missed.">      if (p != null &amp;&amp; p.getTextLength() &gt; 0) {</span>
<span class="fc" id="L244">        return new DOI(p.getText());</span>
      }
<span class="nc" id="L246">      return null;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>